<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="关于这篇文章：  内容：Linux的 epoll 的API和它的实现。 目的：学习Java Nio的过程中，想了解一下 epoll 注意：部分内容来自网上，不敢保证一定对。">
<meta name="keywords" content="IO,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux的epoll">
<meta property="og:url" content="http://yoursite.com/2018/03/03/Linux_epoll/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="关于这篇文章：  内容：Linux的 epoll 的API和它的实现。 目的：学习Java Nio的过程中，想了解一下 epoll 注意：部分内容来自网上，不敢保证一定对。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/assets/blogImg/linux_epoll/1.png">
<meta property="og:updated_time" content="2019-05-11T07:18:07.083Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux的epoll">
<meta name="twitter:description" content="关于这篇文章：  内容：Linux的 epoll 的API和它的实现。 目的：学习Java Nio的过程中，想了解一下 epoll 注意：部分内容来自网上，不敢保证一定对。">
<meta name="twitter:image" content="http://yoursite.com/assets/blogImg/linux_epoll/1.png">





  
  
  <link rel="canonical" href="http://yoursite.com/2018/03/03/Linux_epoll/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Linux的epoll | Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/03/Linux_epoll/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JH_Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Linux的epoll

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-03-03 19:12:00" itemprop="dateCreated datePublished" datetime="2018-03-03T19:12:00+08:00">2018-03-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-11 15:18:07" itemprop="dateModified" datetime="2019-05-11T15:18:07+08:00">2019-05-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/基础/" itemprop="url" rel="index"><span itemprop="name">基础</span></a></span>

                
                
                  ，
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/基础/CS/" itemprop="url" rel="index"><span itemprop="name">CS</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>关于这篇文章：</p>
<ul>
<li>内容：Linux的 epoll 的API和它的实现。</li>
<li>目的：学习Java Nio的过程中，想了解一下 epoll</li>
<li>注意：部分内容来自网上，不敢保证一定对。</li>
</ul>
<a id="more"></a>
<h3 id="epoll的介绍"><a href="#epoll的介绍" class="headerlink" title="epoll的介绍"></a>epoll的介绍</h3><h4 id="epoll的3个接口"><a href="#epoll的3个接口" class="headerlink" title="epoll的3个接口"></a>epoll的3个接口</h4><h5 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size)</span><br></pre></td></tr></table></figure>
<p>创建一个 epoll 文件描述符,size指明这个epoll监听的数目有多大，实际上现在这个 size 是被忽略的（内核使用红黑树组织epoll相关数据结构，不再使用这个参数）。</p>
<h5 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br></pre></td></tr></table></figure>
<p>入参解析：</p>
<ul>
<li>epfd ：1个文件描述符，引用的是 epoll 实例，也是这个系统调用操作的对象。</li>
<li>fd ：操作的目标文件描述符</li>
<li><p>op ： 表示操作的类型，可选的值有：</p>
<ul>
<li>EPOLL_CTL_ADD ：将目标文件描述符 fd 添加到 epfd 引用的 epoll 实例，并且与 event关联起来。</li>
<li>EPOLL_CTL_MOD ：修改 fd 关联的 event </li>
<li>EPOLL_CTL_DEL ：将目标文件描述符 fd 从 epfd 引用的 epoll 实例中删除，event参数被忽略。</li>
</ul>
</li>
<li><p>event ：是一个结构体，包含 event信息和用户自定义信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 这是一个union一次只能存储其中一种数据，可以是文件描述符fd，</span><br><span class="line">// 可以是传递的数据void*，可以是一个无符号长整形等等，但是最经常使用的是fd</span><br><span class="line">typedef union epoll_data &#123;</span><br><span class="line">  void        *ptr;</span><br><span class="line">  int          fd;</span><br><span class="line">  uint32_t     u32;</span><br><span class="line">  uint64_t     u64;</span><br><span class="line">&#125; epoll_data_t;</span><br><span class="line"></span><br><span class="line">struct epoll_event &#123;</span><br><span class="line">  uint32_t     events;      /* Epoll events */</span><br><span class="line">  epoll_data_t data;        /* User data variable */</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// events有以下几种：</span><br><span class="line">EPOLLIN ：表示对应的文件描述符可读(包括对端socket关闭)</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的；</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里。</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int epoll_wait(int epfd, struct epoll_event *events,</span><br><span class="line">               int maxevents, int timeout);</span><br></pre></td></tr></table></figure>
<p>入参解析：</p>
<ul>
<li>epfd ： 引用的是 epoll 实例，也是这个系统调用操作的对象。</li>
<li>events ：用于保存这个系统调用的返回值，即就绪的 event</li>
<li>maxevents ：用户想监听的 fd 的数目</li>
<li>timeout ： 超时时间 (0表示立即返回，-1表示永久阻塞，直到有就绪事件)</li>
</ul>
<h4 id="epoll-的-LT-和-ET"><a href="#epoll-的-LT-和-ET" class="headerlink" title="epoll 的 LT 和 ET"></a>epoll 的 LT 和 ET</h4><h5 id="LT（Level-Triggered）水平触发"><a href="#LT（Level-Triggered）水平触发" class="headerlink" title="LT（Level Triggered）水平触发"></a>LT（Level Triggered）水平触发</h5><p>LT是缺省的工作方式，并且同时支持block和no-block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p>
<h5 id="ET（Edge-Triggered）边缘触发"><a href="#ET（Edge-Triggered）边缘触发" class="headerlink" title="ET（Edge Triggered）边缘触发"></a>ET（Edge Triggered）边缘触发</h5><p>ET是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。</p>
<h4 id="epoll的使用例子"><a href="#epoll的使用例子" class="headerlink" title="epoll的使用例子"></a>epoll的使用例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#define MAX_EVENTS 10</span><br><span class="line">struct epoll_event ev, events[MAX_EVENTS];</span><br><span class="line">int listen_sock, conn_sock, nfds, epollfd;</span><br><span class="line"></span><br><span class="line">/* Set up listening socket, &apos;listen_sock&apos; (socket(),</span><br><span class="line">   bind(), listen()) */</span><br><span class="line"></span><br><span class="line">epollfd = epoll_create(10);</span><br><span class="line">if (epollfd == -1) &#123;</span><br><span class="line">    perror(&quot;epoll_create&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ev.events = EPOLLIN;</span><br><span class="line">ev.data.fd = listen_sock;</span><br><span class="line">if (epoll_ctl(epollfd, EPOLL_CTL_ADD, listen_sock, &amp;ev) == -1) &#123;</span><br><span class="line">    perror(&quot;epoll_ctl: listen_sock&quot;);</span><br><span class="line">    exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (;;) &#123;</span><br><span class="line">    nfds = epoll_wait(epollfd, events, MAX_EVENTS, -1);</span><br><span class="line">    if (nfds == -1) &#123;</span><br><span class="line">        perror(&quot;epoll_pwait&quot;);</span><br><span class="line">        exit(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   for (n = 0; n &lt; nfds; ++n) &#123;</span><br><span class="line">        if (events[n].data.fd == listen_sock) &#123;</span><br><span class="line">            conn_sock = accept(listen_sock,</span><br><span class="line">                            (struct sockaddr *) &amp;local, &amp;addrlen);</span><br><span class="line">            if (conn_sock == -1) &#123;</span><br><span class="line">                perror(&quot;accept&quot;);</span><br><span class="line">                exit(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">            setnonblocking(conn_sock);</span><br><span class="line">            ev.events = EPOLLIN | EPOLLET;</span><br><span class="line">            ev.data.fd = conn_sock;</span><br><span class="line">            if (epoll_ctl(epollfd, EPOLL_CTL_ADD, conn_sock,</span><br><span class="line">                        &amp;ev) == -1) &#123;</span><br><span class="line">                perror(&quot;epoll_ctl: conn_sock&quot;);</span><br><span class="line">                exit(EXIT_FAILURE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            do_use_fd(events[n].data.fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="epoll的实现"><a href="#epoll的实现" class="headerlink" title="epoll的实现"></a>epoll的实现</h3><h4 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h4><p><img src="/assets/blogImg/linux_epoll/1.png" alt></p>
<p>介绍上面的数据结构。</p>
<h5 id="epitem"><a href="#epitem" class="headerlink" title="epitem"></a>epitem</h5><p>当向系统中添加一个fd时，就创建一个epitem结构体，这是内核管理epoll的基本数据结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">struct epitem &#123;</span><br><span class="line"></span><br><span class="line">    struct rb_node  rbn;        //用于主结构管理的红黑树</span><br><span class="line">    struct list_head  rdllink;  //事件就绪队列</span><br><span class="line">    struct epitem  *next;       //用于主结构体中的链表</span><br><span class="line">    struct epoll_filefd  ffd;   //这个结构体对应的被监听的文件描述符信息</span><br><span class="line">    int  nwait;                 //poll操作中事件的个数</span><br><span class="line">    struct list_head  pwqlist;  //双向链表，保存着被监视文件的等待队列，功能类似于select/poll中的poll_table</span><br><span class="line">    struct eventpoll  *ep;      //该项属于哪个主结构体（多个epitm从属于一个eventpoll）</span><br><span class="line">    struct list_head  fllink;   //双向链表，用来链接被监视的文件描述符对应的struct file。因为file里有f_ep_link,用来保存所有监视这个文件的epoll节点</span><br><span class="line">    struct epoll_event  event;  //注册的感兴趣的事件,也就是用户空间的epoll_event</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="eventpoll"><a href="#eventpoll" class="headerlink" title="eventpoll"></a>eventpoll</h5><p>每个epoll fd（epfd）对应的主要数据结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct eventpoll &#123;</span><br><span class="line"></span><br><span class="line">    spin_lock_t       lock;        //对本数据结构的访问</span><br><span class="line">    struct mutex      mtx;         //防止使用时被删除</span><br><span class="line">    wait_queue_head_t     wq;      //sys_epoll_wait() 使用的等待队列</span><br><span class="line">    wait_queue_head_t   poll_wait;       //file-&gt;poll()使用的等待队列</span><br><span class="line">    struct list_head    rdllist;        //事件满足条件的链表</span><br><span class="line">    struct rb_root      rbr;            //用于管理所有fd的红黑树（树根）</span><br><span class="line">    struct epitem      *ovflist;       //将事件到达的fd进行链接起来发送至用户空间</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="eventpoll-init"><a href="#eventpoll-init" class="headerlink" title="eventpoll_init"></a>eventpoll_init</h4><p>epoll需要占用某些系统资源。Linux内核在系统启动时，其实已经提前完成了该部分资源的分配和初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* 本文的内核源码版本为linux-3.10.103 */</span><br><span class="line"></span><br><span class="line">/* linux-3.10.103/linux-3.10.103/fs/eventpoll.c */</span><br><span class="line"></span><br><span class="line">static int __init eventpoll_init(void)</span><br><span class="line">&#123;</span><br><span class="line">    mutex_init(&amp;pmutex);</span><br><span class="line">    ep_poll_safewake_init(&amp;psw);</span><br><span class="line">    </span><br><span class="line">    epi_cache = kmem_cache_create(&quot;eventpoll_epi&quot;, sizeof(struct epitem), 0, SLAB_HWCACHE_ALIGN|EPI_SLAB_DEBUG|SLAB_PANIC, NULL);</span><br><span class="line"></span><br><span class="line">    pwq_cache = kmem_cache_create(&quot;eventpoll_pwq&quot;, sizeof(struct eppoll_entry), 0, EPI_SLAB_DEBUG|SLAB_PANIC, NULL);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“eventpoll_init()”在内核模块加载时将被调用来完成epoll相关的资源分配，从其源码可见，Linux内核为epoll提供了”eventpoll_epi”和”eventpoll_pwq”两块基于slab机制的内存单元,epoll中对象的分配和释放操作非常频繁，slab可以最大程度提升epoll使用内存的效率。</p>
<h4 id="epoll-create-的实现"><a href="#epoll-create-的实现" class="headerlink" title="epoll_create()的实现"></a>epoll_create()的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">long sys_epoll_create(int size) &#123;</span><br><span class="line"></span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line">    ...</span><br><span class="line">    ep_alloc(&amp;ep); //为ep分配内存并进行初始化</span><br><span class="line"></span><br><span class="line">    /* </span><br><span class="line">    * 调用anon_inode_getfd 新建一个file instance，也就是epoll可以看成一个文件（匿名文件）。</span><br><span class="line">    * 因此我们可以看到epoll_create会返回一个fd。</span><br><span class="line">    * epoll所管理的所有的fd都是放在一个大的结构eventpoll(红黑树)中，将主结构体 </span><br><span class="line">    * struct eventpoll *ep 放入 file-&gt;private 项中进行保存（sys_epoll_ctl会取用）</span><br><span class="line">    */</span><br><span class="line"></span><br><span class="line">    fd = anon_inode_getfd(&quot;[eventpoll]&quot;, &amp;eventpoll_fops, ep, O_RDWR | (flags &amp; O_CLOEXEC));</span><br><span class="line">     return fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="epoll-ctl的实现"><a href="#epoll-ctl的实现" class="headerlink" title="epoll_ctl的实现"></a>epoll_ctl的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">asmlinkage long sys_epoll_ctl(int epfd,int op,int fd,struct epoll_event __user *event) &#123;</span><br><span class="line"></span><br><span class="line">    int error;</span><br><span class="line"></span><br><span class="line">    struct file *file,*tfile;</span><br><span class="line"></span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    struct epoll_event epds;</span><br><span class="line"></span><br><span class="line">    error = -FAULT;</span><br><span class="line"></span><br><span class="line">    //判断参数的合法性，将 __user *event 复制给 epds。</span><br><span class="line">    if(ep_op_has_event(op) &amp;&amp; copy_from_user(&amp;epds,event,sizeof(struct epoll_event)))</span><br><span class="line">            goto error_return; //省略跳转到的代码</span><br><span class="line"></span><br><span class="line">    file  = fget (epfd); // epoll fd 对应的文件对象</span><br><span class="line"></span><br><span class="line">    tfile = fget(fd);    // fd 对应的文件对象</span><br><span class="line"></span><br><span class="line">    //在create时存入进去的（anon_inode_getfd），现在取用。</span><br><span class="line">    ep = file-&gt;private-&gt;data;</span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;ep-&gt;mtx);</span><br><span class="line"></span><br><span class="line">    //防止重复添加（在ep的红黑树中查找是否已经存在这个fd）</span><br><span class="line">    epi = epi_find(ep,tfile,fd);</span><br><span class="line"></span><br><span class="line">    switch(op)</span><br><span class="line">    &#123;</span><br><span class="line">       ...</span><br><span class="line">        case EPOLL_CTL_ADD:  //增加监听一个fd</span><br><span class="line">            if(!epi)</span><br><span class="line">            &#123;</span><br><span class="line">                epds.events |= EPOLLERR | POLLHUP;     //默认包含POLLERR和POLLHUP事件</span><br><span class="line"></span><br><span class="line">                error = ep_insert(ep,&amp;epds,tfile,fd);  //在ep的红黑树中插入这个fd对应的epitm结构体。</span><br><span class="line">            &#125; </span><br><span class="line">            else  //重复添加（在ep的红黑树中查找已经存在这个fd）。</span><br><span class="line">                error = -EEXIST;</span><br><span class="line">            break;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ep_insert的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">static int ep_insert(struct eventpoll *ep, struct epoll_event *event, struct file *tfile, int fd)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">   int error ,revents,pwake = 0;</span><br><span class="line">   unsigned long flags ;</span><br><span class="line">   struct epitem *epi;</span><br><span class="line">   </span><br><span class="line">   /*</span><br><span class="line">      struct ep_queue&#123;</span><br><span class="line">         poll_table pt;</span><br><span class="line">         struct epitem *epi;</span><br><span class="line">      &#125;</span><br><span class="line">    */</span><br><span class="line">   struct ep_pqueue epq;</span><br><span class="line"></span><br><span class="line">   //分配一个epitem结构体来保存每个加入的fd</span><br><span class="line">   if(!(epi = kmem_cache_alloc(epi_cache,GFP_KERNEL)))</span><br><span class="line">      goto error_return;</span><br><span class="line"></span><br><span class="line">   //初始化该结构体</span><br><span class="line">   ep_rb_initnode(&amp;epi-&gt;rbn);</span><br><span class="line">   INIT_LIST_HEAD(&amp;epi-&gt;rdllink);</span><br><span class="line">   INIT_LIST_HEAD(&amp;epi-&gt;fllink);</span><br><span class="line">   INIT_LIST_HEAD(&amp;epi-&gt;pwqlist);</span><br><span class="line">   epi-&gt;ep = ep;</span><br><span class="line">   ep_set_ffd(&amp;epi-&gt;ffd,tfile,fd);</span><br><span class="line">   epi-&gt;event = *event;</span><br><span class="line">   epi-&gt;nwait = 0;</span><br><span class="line">   epi-&gt;next = EP_UNACTIVE_PTR;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   epq.epi = epi;</span><br><span class="line">   //安装poll回调函数</span><br><span class="line">   init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc );</span><br><span class="line"></span><br><span class="line">   /* </span><br><span class="line">   * 调用poll函数来获取当前事件位，其实是利用它来调用注册函数ep_ptable_queue_proc（poll_wait中调用）。</span><br><span class="line">   * 如果fd是套接字，f_op为socket_file_ops，poll函数是 sock_poll()。</span><br><span class="line">   * 如果是TCP套接字的话，进而会调用到tcp_poll()函数。</span><br><span class="line">   * 此处调用poll函数查看当前文件描述符的状态，存储在revents中。</span><br><span class="line">   * 在poll的处理函数(tcp_poll())中，会调用sock_poll_wait()，在sock_poll_wait()中会调用</span><br><span class="line">     到epq.pt.qproc指向的函数，也就是ep_ptable_queue_proc()。  </span><br><span class="line">    */ </span><br><span class="line">   revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br><span class="line"></span><br><span class="line">   spin_lock(&amp;tfile-&gt;f_ep_lock);</span><br><span class="line">   list_add_tail(&amp;epi-&gt;fllink,&amp;tfile-&gt;f_ep_lilnks);</span><br><span class="line">   spin_unlock(&amp;tfile-&gt;f_ep_lock);</span><br><span class="line"></span><br><span class="line">   ep_rbtree_insert(ep,epi); //将该epi插入到ep的红黑树中</span><br><span class="line"></span><br><span class="line">   spin_lock_irqsave(&amp;ep-&gt;lock,flags);</span><br><span class="line"></span><br><span class="line">    //  revents &amp; event-&gt;events：刚才fop-&gt;poll的返回值中标识的事件有用户event关心的事件发生。</span><br><span class="line"></span><br><span class="line">    // !ep_is_linked(&amp;epi-&gt;rdllink)：epi的ready队列中有数据。ep_is_linked用于判断队列是否为空。</span><br><span class="line"></span><br><span class="line">    /*  </span><br><span class="line">    * 如果要监视的文件状态已经就绪并且还没有加入到就绪队列中,则将当前的 </span><br><span class="line">    * epitem加入到就绪队列中.如果有进程正在等待该文件的状态就绪,则唤醒一个等待的进程。</span><br><span class="line">    */ </span><br><span class="line">    if((revents &amp; event-&gt;events) &amp;&amp; !ep_is_linked(&amp;epi-&gt;rdllink)) &#123;</span><br><span class="line">      list_add_tail(&amp;epi-&gt;rdllink,&amp;ep-&gt;rdllist); //将当前epi插入到ep-&gt;ready队列中。</span><br><span class="line"></span><br><span class="line">    /* </span><br><span class="line">    * 如果有进程正在等待文件的状态就绪，也就是调用epoll_wait睡眠的进程正在等待，则唤醒一个等待进程。</span><br><span class="line">    * waitqueue_active(q) 等待队列q中有等待的进程返回1，否则返回0。</span><br><span class="line">    */</span><br><span class="line">      if(waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">         __wake_up_locked(&amp;ep-&gt;wq,TAKS_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);</span><br><span class="line">         </span><br><span class="line">        /*  </span><br><span class="line">        * 如果有进程等待eventpoll文件本身（???）的事件就绪，则增加临时变量pwake的值，</span><br><span class="line">        * pwake的值不为0时，在释放lock后，会唤醒等待进程。 </span><br><span class="line">        */ </span><br><span class="line">      if(waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">         pwake++;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   spin_unlock_irqrestore(&amp;ep-&gt;lock,flags);</span><br><span class="line"></span><br><span class="line">    if(pwake)</span><br><span class="line">      ep_poll_safewake(&amp;psw,&amp;ep-&gt;poll_wait);    //唤醒等待eventpoll文件状态就绪的进程</span><br><span class="line"></span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">init_poll_funcptr(&amp;epq.pt, ep_ptable_queue_proc);</span><br><span class="line">revents = tfile-&gt;f_op-&gt;poll(tfile, &amp;epq.pt);</span><br></pre></td></tr></table></figure></p>
<p>这2个函数将ep_ptable_queue_proc注册到epq.pt中的qproc：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct poll_table_struct &#123;</span><br><span class="line">    poll_queue_proc qproc;</span><br><span class="line">    unsigned long key;</span><br><span class="line">&#125;poll_table;</span><br></pre></td></tr></table></figure></p>
<p>执行<code>f_op-&gt;poll(tfile, &amp;epq.pt)</code>时，<font color="orange">XXX_poll(tfile, &amp;epq.pt)</font> 函数会执行poll_wait()，poll_wait()会调用epq.pt.qproc函数，即ep_ptable_queue_proc。</p>
<p>ep_ptable_queue_proc函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 在文件操作中的poll函数中调用，将epoll的回调函数加入到目标文件的唤醒队列中。</span><br><span class="line"> * 如果监视的文件是套接字，参数whead则是sock结构的sk_sleep成员的地址。  </span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">static void ep_ptable_queue_proc(struct file *file, wait_queue_head_t *whead, poll_table *pt) &#123;</span><br><span class="line"></span><br><span class="line">    /* struct ep_queue&#123;</span><br><span class="line">        poll_table pt;</span><br><span class="line">        struct epitem *epi;</span><br><span class="line">      &#125; */</span><br><span class="line">    struct epitem *epi = ep_item_from_epqueue(pt); //pt获取struct ep_queue的epi字段。</span><br><span class="line">    struct eppoll_entry *pwq;</span><br><span class="line"></span><br><span class="line">    if (epi-&gt;nwait &gt;= 0 &amp;&amp; (pwq = kmem_cache_alloc(pwq_cache, GFP_KERNEL))) &#123;</span><br><span class="line">        init_waitqueue_func_entry(&amp;pwq-&gt;wait, ep_poll_callback);</span><br><span class="line">        pwq-&gt;whead = whead;</span><br><span class="line">        pwq-&gt;base = epi;</span><br><span class="line">        add_wait_queue(whead, &amp;pwq-&gt;wait);</span><br><span class="line">        list_add_tail(&amp;pwq-&gt;llink, &amp;epi-&gt;pwqlist);</span><br><span class="line">        epi-&gt;nwait++;</span><br><span class="line">    &#125; </span><br><span class="line">    else &#123;</span><br><span class="line"></span><br><span class="line">        /* We have to signal that an error occurred */</span><br><span class="line">        /*</span><br><span class="line">         * 如果分配内存失败，则将nwait置为-1，表示</span><br><span class="line">         * 发生错误，即内存分配失败，或者已发生错误</span><br><span class="line">         */</span><br><span class="line">        epi-&gt;nwait = -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ep_ptable_queue_proc</code>函数完成<code>epitem</code>加入到特定文件的wait队列任务。</p>
<p>ep_ptable_queue_proc有三个参数：</p>
<ul>
<li><code>struct file *file</code> ：  该fd对应的文件对象</li>
<li><code>wait_queue_head_t *whead</code> ： 该fd对应的设备等待队列（同select中的mydev-&gt;wait_address）</li>
<li><code>poll_table *pt;</code> ：f_op-&gt;poll(tfile, &amp;epq.pt)中的epq.pt</li>
</ul>
<p>在<code>ep_ptable_queue_proc</code>函数中，引入了另外一个非常重要的数据结构<code>eppoll_entry</code>。<code>eppoll_entry</code><font color="orange">主要完成epitem和epitem事件发生时的callback（ep_poll_callback）函数之间的关联</font>。<font color="red"><br>首先将eppoll_entry的whead指向fd的设备等待队列（同select中的wait_address），然后初始化<code>eppoll_entry</code>的base变量指向epitem，最后通过<code>add_wait_queue</code>将<code>epoll_entry</code>挂载到fd的设备等待队列上。完成这个动作后，<code>epoll_entry</code>已经被挂载到fd的设备等待队列。</font></p>
<p>其中struct eppoll_entry定义如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct eppoll_entry &#123;</span><br><span class="line">    struct list_head llink;</span><br><span class="line">    struct epitem *base;</span><br><span class="line">    wait_queue_t wait;</span><br><span class="line">    wait_queue_head_t *whead;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><font color="orange">由于<code>ep_ptable_queue_proc</code>函数设置了等待队列的<code>ep_poll_callback</code>回调函数。所以在设备硬件数据到来时，硬件中断处理函数中会唤醒该等待队列上等待的进程时，会调用唤醒函数<code>ep_poll_callback</code></font>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *key) &#123;</span><br><span class="line"></span><br><span class="line">    int pwake = 0;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    struct epitem *epi = ep_item_from_wait(wait);</span><br><span class="line">    struct eventpoll *ep = epi-&gt;ep;</span><br><span class="line"></span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    //判断注册的感兴趣事件</span><br><span class="line"></span><br><span class="line">    //#define EP_PRIVATE_BITS  (EPOLLONESHOT | EPOLLET)</span><br><span class="line">    //有非EPOLLONESHONT或EPOLLET事件</span><br><span class="line">    if (!(epi-&gt;event.events &amp; ~EP_PRIVATE_BITS))</span><br><span class="line">        goto out_unlock;</span><br><span class="line"></span><br><span class="line">    if (unlikely(ep-&gt;ovflist != EP_UNACTIVE_PTR)) &#123;</span><br><span class="line">        if (epi-&gt;next == EP_UNACTIVE_PTR) &#123;</span><br><span class="line">            epi-&gt;next = ep-&gt;ovflist;</span><br><span class="line">            ep-&gt;ovflist = epi;</span><br><span class="line">      &#125;</span><br><span class="line">        goto out_unlock;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    if (ep_is_linked(&amp;epi-&gt;rdllink))</span><br><span class="line">        goto is_linked;</span><br><span class="line"></span><br><span class="line">    //***关键***，将该fd加入到epoll监听的就绪链表中</span><br><span class="line">    list_add_tail(&amp;epi-&gt;rdllink, &amp;ep-&gt;rdllist);</span><br><span class="line">    //唤醒调用epoll_wait()函数时睡眠的进程。用户层epoll_wait(...) 超时前返回。</span><br><span class="line">    if (waitqueue_active(&amp;ep-&gt;wq))</span><br><span class="line">        __wake_up_locked(&amp;ep-&gt;wq, TASK_UNINTERRUPTIBLE | TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">    if (waitqueue_active(&amp;ep-&gt;poll_wait))</span><br><span class="line">        pwake++;</span><br><span class="line"></span><br><span class="line">    out_unlock: spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    if (pwake)</span><br><span class="line">        ep_poll_safewake(&amp;psw, &amp;ep-&gt;poll_wait);</span><br><span class="line"></span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以<code>ep_poll_callback</code>函数主要的功能是<font color="orange">将被监视文件的等待事件就绪时，将文件对应的epitem实例添加到就绪队列中</font>，当用户调用<code>epoll_wait()</code>时，内核会将就绪队列中的事件报告给用户。</p>
<h4 id="epoll-wait的实现"><a href="#epoll-wait的实现" class="headerlink" title="epoll_wait的实现"></a>epoll_wait的实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL_DEFINE4(epoll_wait, int, epfd, struct epoll_event __user *, events, int, maxevents, int, timeout)  &#123;</span><br><span class="line"></span><br><span class="line">    int error;</span><br><span class="line">    struct file *file;</span><br><span class="line">    struct eventpoll *ep;</span><br><span class="line"></span><br><span class="line">    /* 检查maxevents参数。 */</span><br><span class="line">    if (maxevents &lt;= 0 || maxevents &gt; EP_MAX_EVENTS)</span><br><span class="line">        return -EINVAL;</span><br><span class="line"></span><br><span class="line">    /* 检查用户空间传入的events指向的内存是否可写。参见__range_not_ok()。 */</span><br><span class="line">    if (!access_ok(VERIFY_WRITE, events, maxevents * sizeof(struct epoll_event))) &#123;</span><br><span class="line">        error = -EFAULT;</span><br><span class="line">        goto error_return;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    /* 获取epfd对应的eventpoll文件的file实例，file结构是在epoll_create中创建。 */</span><br><span class="line">    error = -EBADF;</span><br><span class="line">    file = fget(epfd);</span><br><span class="line">    </span><br><span class="line">    if (!file)</span><br><span class="line">        goto error_return;</span><br><span class="line"></span><br><span class="line">    /* 通过检查epfd对应的文件操作是不是eventpoll_fops 来判断epfd是否是一个eventpoll文件。如果不是则返回EINVAL错误。 */</span><br><span class="line">    error = -EINVAL;</span><br><span class="line"></span><br><span class="line">    if (!is_file_epoll(file))</span><br><span class="line">        goto error_fput;</span><br><span class="line"></span><br><span class="line">    /* At this point it is safe to assume that the &quot;private_data&quot; contains  */</span><br><span class="line">    ep = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    /* Time to fish for events ... */</span><br><span class="line">    error = ep_poll(ep, events, maxevents, timeout);</span><br><span class="line"></span><br><span class="line">    error_fput:</span><br><span class="line"></span><br><span class="line">    fput(file);</span><br><span class="line"></span><br><span class="line">    error_return:</span><br><span class="line"></span><br><span class="line">    return error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>epoll_wait</code>调用<code>ep_poll</code>，<code>ep_poll</code>实现如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">static int ep_poll(struct eventpoll *ep, struct epoll_event __user *events, int maxevents, long timeout) &#123;</span><br><span class="line"></span><br><span class="line">    int res, eavail;</span><br><span class="line">    unsigned long flags;</span><br><span class="line">    long jtimeout;</span><br><span class="line">    wait_queue_t wait;</span><br><span class="line"></span><br><span class="line">    /* timeout是以毫秒为单位，这里是要转换为jiffies时间。这里加上999(即1000-1)，是为了向上取整。 */</span><br><span class="line">    jtimeout = (timeout &lt; 0 || timeout &gt;= EP_MAX_MSTIMEO) ?MAX_SCHEDULE_TIMEOUT : (timeout * HZ + 999) / 1000;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">    res = 0;</span><br><span class="line">    </span><br><span class="line">    if (list_empty(&amp;ep-&gt;rdllist)) &#123;</span><br><span class="line">    /* 没有事件，所以需要睡眠。当有事件到来时，睡眠会被ep_poll_callback函数唤醒。*/</span><br><span class="line"></span><br><span class="line">    init_waitqueue_entry(&amp;wait, current); //将current进程放在wait这个等待队列中。</span><br><span class="line">    wait.flags |= WQ_FLAG_EXCLUSIVE;</span><br><span class="line"></span><br><span class="line">    /* 将当前进程加入到eventpoll的等待队列中，等待文件状态就绪或直到超时，或被信号中断。 */</span><br><span class="line">    __add_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line"></span><br><span class="line">    for (;;) &#123;</span><br><span class="line"></span><br><span class="line">        /* 执行ep_poll_callback()唤醒时应当需要将当前进程唤醒，所以当前进程状态应该为“可唤醒”TASK_INTERRUPTIBLE  */</span><br><span class="line">        set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"></span><br><span class="line">        /* 如果就绪队列不为空，也就是说已经有文件的状态就绪或者超时，则退出循环。*/</span><br><span class="line">        if (!list_empty(&amp;ep-&gt;rdllist) || !jtimeout)</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        /* 如果当前进程接收到信号，则退出循环，返回EINTR错误 */</span><br><span class="line">        if (signal_pending(current)) &#123;</span><br><span class="line">            res = -EINTR;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">        /* </span><br><span class="line">        * 主动让出处理器，等待ep_poll_callback()将当前进程唤醒或者超时,返回值是剩余的时间。</span><br><span class="line">        * 从这里开始当前进程会进入睡眠状态，直到某些文件的状态就绪或者超时。</span><br><span class="line">        * 当文件状态就绪时，eventpoll的回调函数ep_poll_callback()会唤醒在ep-&gt;wq指向的等待队列中的进程。</span><br><span class="line">        */</span><br><span class="line">        jtimeout = schedule_timeout(jtimeout);</span><br><span class="line">        spin_lock_irqsave(&amp;ep-&gt;lock, flags);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">        __remove_wait_queue(&amp;ep-&gt;wq, &amp;wait);</span><br><span class="line">        set_current_state(TASK_RUNNING);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /* </span><br><span class="line">    * ep-&gt;ovflist链表存储的向用户传递事件时暂存就绪的文件。</span><br><span class="line">    * 所以不管是就绪队列ep-&gt;rdllist不为空，或者ep-&gt;ovflist不等于</span><br><span class="line">    * EP_UNACTIVE_PTR，都有可能现在已经有文件的状态就绪。</span><br><span class="line">    * ep-&gt;ovflist不等于EP_UNACTIVE_PTR有两种情况，一种是NULL，此时</span><br><span class="line">    * 可能正在向用户传递事件，不一定就有文件状态就绪，</span><br><span class="line">    * 一种情况时不为NULL，此时可以肯定有文件状态就绪，</span><br><span class="line">    * 参见ep_send_events()。</span><br><span class="line">    */</span><br><span class="line">    eavail = !list_empty(&amp;ep-&gt;rdllist) || ep-&gt;ovflist != EP_UNACTIVE_PTR;</span><br><span class="line">    </span><br><span class="line">    spin_unlock_irqrestore(&amp;ep-&gt;lock, flags);</span><br><span class="line"></span><br><span class="line">    /* Try to transfer events to user space. In case we get 0 events and there&apos;s still timeout left over, we go trying again in search of more luck. */</span><br><span class="line">    /* </span><br><span class="line">    * 如果没有被信号中断，并且有事件就绪，但是没有获取到事件(有可能被其他进程获取到了)，并且没有超时，</span><br><span class="line">    * 则跳转到retry标签处，重新等待文件状态就绪。 </span><br><span class="line">    */</span><br><span class="line">    if (!res &amp;&amp; eavail &amp;&amp; !(res = ep_send_events(ep, events, maxevents)) &amp;&amp; jtimeout)</span><br><span class="line">        goto retry;</span><br><span class="line"></span><br><span class="line">    /* 返回获取到的事件的个数或者错误码 */</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="epoll为什么高效（相比select）："><a href="#epoll为什么高效（相比select）：" class="headerlink" title="epoll为什么高效（相比select）："></a>epoll为什么高效（相比select）：</h5><ul>
<li><p>传递 fd ： select/poll每次调用都要传递所要监控的所有fd给select/poll系统调用（这意味着每次调用都要将fd列表从用户态拷贝到内核态，当fd数目很多时，这会造成低效）。而每次调用epoll_wait时（作用相当于调用select/poll），不需要再传递fd列表给内核，因为已经在epoll_ctl中将需要监控的fd告诉了内核（epoll_ctl不需要每次都拷贝所有的fd，只需要进行增量式操作）。所以，在调用epoll_create之后，内核已经在内核态开始准备数据结构存放要监控的fd了。每次epoll_ctl只是对这个数据结构进行简单的维护。</p>
</li>
<li><p>epoll使用了slab机制 ：在内核里，一切皆文件。所以，epoll向内核注册了一个文件系统，用于存储上述的被监控的fd。当你调用epoll_create时，就会在这个虚拟的epoll文件系统里创建一个file结点。当然这个file不是普通文件，它只服务于epoll。epoll在被内核初始化时（操作系统启动），同时会开辟出epoll自己的内核高速cache区，用于安置每一个我们想监控的fd，这些fd会以红黑树的形式保存在内核cache里，以支持快速的查找、插入、删除。这个内核高速cache区，就是建立连续的物理内存页，然后在之上建立slab层，简单的说，就是物理上分配好你想要的size的内存对象，每次使用时都是使用空闲的已分配好的对象。 </p>
</li>
<li>遍历 fd : 当我们调用epoll_ctl往里塞入百万个fd时，epoll_wait仍然可以飞快的返回，并有效的将发生事件的fd给我们用户。这是由于我们在调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个红黑树用于存储以后epoll_ctl传来的fd外，还会再建立一个list链表，用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。而且，通常情况下即使我们要监控百万计的fd，大多一次也只返回很少量的准备就绪fd而已，所以，epoll_wait仅需要从内核态copy少量的fd到用户态而已。那么，这个准备就绪list链表是怎么维护的呢？当我们执行epoll_ctl时，除了把fd放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个fd的中断到了，就把它放到准备就绪list链表里。所以，当一个fd（例如socket）上有数据到了，内核在把设备（例如网卡）上的数据copy到内核中后就来把fd（socket）插入到准备就绪list链表里了。</li>
</ul>
<h5 id="3个系统调用的概括"><a href="#3个系统调用的概括" class="headerlink" title="3个系统调用的概括"></a>3个系统调用的概括</h5><ol>
<li>执行epoll_create时，创建了红黑树和就绪list链表。</li>
<li>执行epoll_ctl时，如果增加fd（socket），则检查在红黑树中是否存在，存在立即返回，不存在则添加到红黑树上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪list链表中插入数据。</li>
<li>执行epoll_wait时立刻返回准备就绪链表里的数据即可。</li>
</ol>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>epoll有两种模式LT(水平触发)和ET(边缘触发)，LT模式下，主要缓冲区数据一次没有处理完，那么下次epoll_wait返回时，还会返回这个句柄；而ET模式下，缓冲区数据一次没处理结束，那么下次是不会再通知了，只在第一次返回．所以在ET模式下，一般是通过while循环，一次性读完全部数据．epoll默认使用的是LT。</p>
<p>这件事怎么做到的呢？当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait干了件事，就是检查这些socket，如果不是ET模式（就是LT模式的句柄了），并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表了。所以，非ET的句柄，只要它上面还有事件，epoll_wait每次都会返回。而ET模式的句柄，除非有新中断到，即使socket上的事件没有处理完，也是不会次次从epoll_wait返回的．</p>
<p>经常看到比较ET和LT模式到底哪个效率高的问题．有一个回答是说ET模式下减少epoll系统调用．这话没错，也可以理解，但是在ET模式下，为了避免数据饿死问题，用户态必须用一个循环，将所有的数据一次性处理结束．所以在ET模式下下，虽然epoll系统调用减少了，但是用户态的逻辑复杂了，write/read调用增多了．所以这不好判断，要看用户的性能瓶颈在哪．</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/IO/" rel="tag"># IO</a>
          
            <a href="/tags/Linux/" rel="tag"># Linux</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/02/Linux_mmap/" rel="next" title="Linux的mmap">
                <i class="fa fa-chevron-left"></i> Linux的mmap
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/01/Java_Basic_NIO/" rel="prev" title="Java NIO 简介">
                Java NIO 简介 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JH_Chen</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">14</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll的介绍"><span class="nav-number">1.</span> <span class="nav-text">epoll的介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll的3个接口"><span class="nav-number">1.1.</span> <span class="nav-text">epoll的3个接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll-create"><span class="nav-number">1.1.1.</span> <span class="nav-text">epoll_create</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll-ctl"><span class="nav-number">1.1.2.</span> <span class="nav-text">epoll_ctl</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll-wait"><span class="nav-number">1.1.3.</span> <span class="nav-text">epoll_wait</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-的-LT-和-ET"><span class="nav-number">1.2.</span> <span class="nav-text">epoll 的 LT 和 ET</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LT（Level-Triggered）水平触发"><span class="nav-number">1.2.1.</span> <span class="nav-text">LT（Level Triggered）水平触发</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ET（Edge-Triggered）边缘触发"><span class="nav-number">1.2.2.</span> <span class="nav-text">ET（Edge Triggered）边缘触发</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll的使用例子"><span class="nav-number">1.3.</span> <span class="nav-text">epoll的使用例子</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#epoll的实现"><span class="nav-number">2.</span> <span class="nav-text">epoll的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相关数据结构"><span class="nav-number">2.1.</span> <span class="nav-text">相关数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#epitem"><span class="nav-number">2.1.1.</span> <span class="nav-text">epitem</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#eventpoll"><span class="nav-number">2.1.2.</span> <span class="nav-text">eventpoll</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#eventpoll-init"><span class="nav-number">2.2.</span> <span class="nav-text">eventpoll_init</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-create-的实现"><span class="nav-number">2.3.</span> <span class="nav-text">epoll_create()的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-ctl的实现"><span class="nav-number">2.4.</span> <span class="nav-text">epoll_ctl的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll-wait的实现"><span class="nav-number">2.5.</span> <span class="nav-text">epoll_wait的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">2.6.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#epoll为什么高效（相比select）："><span class="nav-number">2.6.1.</span> <span class="nav-text">epoll为什么高效（相比select）：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3个系统调用的概括"><span class="nav-number">2.6.2.</span> <span class="nav-text">3个系统调用的概括</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补充"><span class="nav-number">2.7.</span> <span class="nav-text">补充</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JH_Chen</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.1</div>






        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
