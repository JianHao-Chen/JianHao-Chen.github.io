<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="本文研究HotSpot新生代DefNewGeneration的实现。">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="HotSpot新生代DefNewGeneration的实现">
<meta property="og:url" content="http://yoursite.com/2019/06/18/JVM_GC_DefNewGeneration/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="本文研究HotSpot新生代DefNewGeneration的实现。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-12T08:24:26.596Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="HotSpot新生代DefNewGeneration的实现">
<meta name="twitter:description" content="本文研究HotSpot新生代DefNewGeneration的实现。">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/06/18/JVM_GC_DefNewGeneration/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>HotSpot新生代DefNewGeneration的实现 | Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/18/JVM_GC_DefNewGeneration/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JH_Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">HotSpot新生代DefNewGeneration的实现

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-18 08:55:00" itemprop="dateCreated datePublished" datetime="2019-06-18T08:55:00+08:00">2019-06-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-12 16:24:26" itemprop="dateModified" datetime="2019-07-12T16:24:26+08:00">2019-07-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>本文研究HotSpot新生代DefNewGeneration的实现。</p>
<a id="more"></a>
<h3 id="DefNewGeneration的定义"><a href="#DefNewGeneration的定义" class="headerlink" title="DefNewGeneration的定义"></a>DefNewGeneration的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class DefNewGeneration: public Generation &#123;</span><br><span class="line"></span><br><span class="line">  protected:</span><br><span class="line">    Generation* _next_gen;</span><br><span class="line">    int         _tenuring_threshold;   // Tenuring threshold for next collection.</span><br><span class="line">    ageTable    _age_table;</span><br><span class="line">    // Size of object to pretenure in words; command line provides bytes</span><br><span class="line">    size_t        _pretenure_size_threshold_words;</span><br><span class="line">    </span><br><span class="line">    // True iff a promotion has failed in the current collection.</span><br><span class="line">    bool   _promotion_failed;</span><br><span class="line">    bool   promotion_failed() &#123; return _promotion_failed; &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /** </span><br><span class="line">    * 处理晋升失败（promotion failure） </span><br><span class="line">    *   如果在收集时，不能将一个对象从它所在的Eden区或from区拷贝出来，收集将失败。</span><br><span class="line">    *   收集前，所有在新生代的 Root，都指向 Eden 或 From 区</span><br><span class="line">    *</span><br><span class="line">    *   收集失败后：</span><br><span class="line">    *     # 对象A在 eden或from区，还有它的一个copy B在 to 区。这时，需要将 root指向A的指针改为指向B。</span><br><span class="line">    *     # 所有新生代的对象都是 unmarked的。</span><br><span class="line">    *     # Eden、from、to区域都需要 Full GC。</span><br><span class="line">    */</span><br><span class="line">    void handle_promotion_failure(oop);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /**</span><br><span class="line">    * 当 promotion failure 发生，删除“转发指针”(forwarding pointer)</span><br><span class="line">    */</span><br><span class="line">    void remove_forwarding_pointers();</span><br><span class="line">    </span><br><span class="line">    // ... 省略部分代码</span><br><span class="line">    </span><br><span class="line">    // Spaces</span><br><span class="line">    EdenSpace*       _eden_space;</span><br><span class="line">    ContiguousSpace* _from_space;</span><br><span class="line">    ContiguousSpace* _to_space;</span><br><span class="line">    </span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下DefNewGeneration定义的一些重要的属性和方法：</p>
<ul>
<li>eden、from、to区，还有对象的晋升阀值</li>
<li>获取space相关信息，如 capacity、used、free等</li>
<li>内存分配</li>
<li>对象遍历相关</li>
<li>晋升失败时的处理</li>
</ul>
<h3 id="DefNewGeneration的初始化"><a href="#DefNewGeneration的初始化" class="headerlink" title="DefNewGeneration的初始化"></a>DefNewGeneration的初始化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">DefNewGeneration::DefNewGeneration(ReservedSpace rs,</span><br><span class="line">                                   size_t initial_size,</span><br><span class="line">                                   int level,</span><br><span class="line">                                   const char* policy)</span><br><span class="line">  : Generation(rs, initial_size, level),</span><br><span class="line">    _promo_failure_drain_in_progress(false),</span><br><span class="line">    _should_allocate_from_space(false)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  MemRegion cmr((HeapWord*)_virtual_space.low(),</span><br><span class="line">                (HeapWord*)_virtual_space.high());</span><br><span class="line">  Universe::heap()-&gt;barrier_set()-&gt;resize_covered_region(cmr);</span><br><span class="line"></span><br><span class="line">  // 1. 创建 Eden、from、to区</span><br><span class="line">  _eden_space = new EdenSpace(this);</span><br><span class="line">  _from_space = new ContiguousSpace();</span><br><span class="line">  _to_space   = new ContiguousSpace();</span><br><span class="line"></span><br><span class="line">  // 2. 如果_eden_space、_from_space、_to_space其中任何一个为空，</span><br><span class="line">  //    说明新生代分配内存失败，则虚拟机退出</span><br><span class="line">  if (_eden_space == NULL || _from_space == NULL || _to_space == NULL)</span><br><span class="line">    vm_exit_during_initialization(&quot;Could not allocate a new gen space&quot;);</span><br><span class="line">    </span><br><span class="line">  // 3. 根据 SurvivorRatio 计算 survivor区的最大size</span><br><span class="line">  //    默认是8，即Eden的size / survivor的size = 8， </span><br><span class="line">  //    即 Eden + from + to = 8 + 1 + 1 </span><br><span class="line">  uintx alignment = GenCollectedHeap::heap()-&gt;collector_policy()-&gt;min_alignment();</span><br><span class="line">  uintx size = _virtual_space.reserved_size();</span><br><span class="line">  _max_survivor_size = compute_survivor_size(size, alignment);</span><br><span class="line">  _max_eden_size = size - (2*_max_survivor_size);</span><br><span class="line">  </span><br><span class="line">  // ... 省略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DefNewGeneration的GC过程"><a href="#DefNewGeneration的GC过程" class="headerlink" title="DefNewGeneration的GC过程"></a>DefNewGeneration的GC过程</h3><p>它的GC过程的实现在<code>DefNewGeneration::collect</code>方法。</p>
<h4 id="检查"><a href="#检查" class="headerlink" title="检查"></a>检查</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">void DefNewGeneration::collect(bool   full,</span><br><span class="line">                               bool   clear_all_soft_refs,</span><br><span class="line">                               size_t size,</span><br><span class="line">                               bool   is_tlab) &#123;</span><br><span class="line">                               </span><br><span class="line">  assert(full || size &gt; 0, &quot;otherwise we don&apos;t want to collect&quot;);</span><br><span class="line">  GenCollectedHeap* gch = GenCollectedHeap::heap();</span><br><span class="line">  _next_gen = gch-&gt;next_gen(this);</span><br><span class="line">  assert(_next_gen != NULL,</span><br><span class="line">    &quot;This must be the youngest gen, and not the only gen&quot;);</span><br><span class="line">    </span><br><span class="line">  // If the next generation is too full to accomodate promotion</span><br><span class="line">  // from this generation, pass on collection; let the next generation</span><br><span class="line">  // do it.</span><br><span class="line">  if (!collection_attempt_is_safe()) &#123;</span><br><span class="line">    if (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">      gclog_or_tty-&gt;print(&quot; :: Collection attempt not safe :: &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    gch-&gt;set_incremental_collection_failed(); // Slight lie: we did not even attempt one</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(to()-&gt;is_empty(), &quot;Else not collection_attempt_is_safe&quot;); </span><br><span class="line">  </span><br><span class="line">  init_assuming_no_promotion_failure();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要是一些检查：</p>
<ul>
<li>确保这是一次 Full GC，或者需要分配的内存大小 size 大于0，否则不执行GC</li>
<li>由于这是新生代，确保它有下一个分代（老年代）</li>
<li>调用<code>collection_attempt_is_safe</code>方法，检查是否适合进行GC</li>
</ul>
<p>其中，<code>collection_attempt_is_safe</code>方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">bool DefNewGeneration::collection_attempt_is_safe() &#123;</span><br><span class="line">  if (!to()-&gt;is_empty()) &#123;</span><br><span class="line">    if (Verbose &amp;&amp; PrintGCDetails) &#123;</span><br><span class="line">      gclog_or_tty-&gt;print(&quot; :: to is not empty :: &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">  if (_next_gen == NULL) &#123;</span><br><span class="line">    GenCollectedHeap* gch = GenCollectedHeap::heap();</span><br><span class="line">    _next_gen = gch-&gt;next_gen(this);</span><br><span class="line">    assert(_next_gen != NULL,</span><br><span class="line">           &quot;This must be the youngest gen, and not the only gen&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return _next_gen-&gt;promotion_attempt_is_safe(used());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法根据以下条件判断GC是否可以执行：</p>
<ul>
<li>to区为空</li>
<li>下一个分代是否可以容纳新生代所有对象</li>
</ul>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// These can be shared for all code paths</span><br><span class="line">IsAliveClosure is_alive(this);</span><br><span class="line">ScanWeakRefClosure scan_weak_ref(this);</span><br><span class="line"></span><br><span class="line">age_table()-&gt;clear();</span><br><span class="line">to()-&gt;clear(SpaceDecorator::Mangle);</span><br><span class="line"></span><br><span class="line">gch-&gt;rem_set()-&gt;prepare_for_younger_refs_iterate(false);</span><br><span class="line"></span><br><span class="line">assert(gch-&gt;no_allocs_since_save_marks(0),</span><br><span class="line">       &quot;save marks have not been newly set.&quot;);</span><br><span class="line"></span><br><span class="line">// Not very pretty.</span><br><span class="line">CollectorPolicy* cp = gch-&gt;collector_policy();</span><br><span class="line"></span><br><span class="line">FastScanClosure fsc_with_no_gc_barrier(this, false);</span><br><span class="line">FastScanClosure fsc_with_gc_barrier(this, true);</span><br><span class="line"></span><br><span class="line">set_promo_failure_scan_stack_closure(&amp;fsc_with_no_gc_barrier);</span><br><span class="line">FastEvacuateFollowersClosure evacuate_followers(gch, _level, this,</span><br><span class="line">                                                &amp;fsc_with_no_gc_barrier,</span><br><span class="line">                                                &amp;fsc_with_gc_barrier);</span><br></pre></td></tr></table></figure>
<p>这里的准备工作有：</p>
<ul>
<li>初始化了几个的 XXClosure，它们的定义、作用后面再说。</li>
<li>清空age_table和to区</li>
<li>创建一个覆盖整个空间的数组GenRemSet，数组每个字节对应于堆的512字节，用于遍历新生代和老年代空间</li>
</ul>
<h4 id="对根集对象标记"><a href="#对根集对象标记" class="headerlink" title="对根集对象标记"></a>对根集对象标记</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gch-&gt;gen_process_strong_roots(_level,</span><br><span class="line">                                true,  // Process younger gens, if any,</span><br><span class="line">                                       // as strong roots.</span><br><span class="line">                                true,  // activate StrongRootsScope</span><br><span class="line">                                false, // not collecting perm generation.</span><br><span class="line">                                SharedHeap::SO_AllClasses,</span><br><span class="line">                                &amp;fsc_with_no_gc_barrier,</span><br><span class="line">                                true,   // walk *all* scavengable nmethods</span><br><span class="line">                                &amp;fsc_with_gc_barrier);</span><br></pre></td></tr></table></figure>
<p>对根集对象标记的过程在<code>GenCollectedHeap::gen_process_strong_roots</code>方法，其中，这个方法可以分为3部分：</p>
<ul>
<li>处理当前分代</li>
<li>处理更低内存分代</li>
<li>处理更高内存分代</li>
</ul>
<h5 id="处理当前分代"><a href="#处理当前分代" class="headerlink" title="处理当前分代"></a>处理当前分代</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (!do_code_roots) &#123;</span><br><span class="line">  SharedHeap::process_strong_roots(activate_scope, collecting_perm_gen, so,</span><br><span class="line">                                   not_older_gens, NULL, older_gens);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  bool do_code_marking = (activate_scope || nmethod::oops_do_marking_is_active());</span><br><span class="line">  CodeBlobToOopClosure code_roots(not_older_gens, /*do_marking=*/ do_code_marking);</span><br><span class="line">  SharedHeap::process_strong_roots(activate_scope, collecting_perm_gen, so,</span><br><span class="line">                                   not_older_gens, &amp;code_roots, older_gens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到其中的<code>SharedHeap::process_strong_roots</code>方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">StrongRootsScope srs(this, activate_scope);</span><br><span class="line">// General strong roots.</span><br><span class="line">assert(_strong_roots_parity != 0, &quot;must have called prologue code&quot;);</span><br><span class="line">if (!_process_strong_tasks-&gt;is_task_claimed(SH_PS_Universe_oops_do)) &#123;</span><br><span class="line">  Universe::oops_do(roots);</span><br><span class="line">  ReferenceProcessor::oops_do(roots);</span><br><span class="line">  // Consider perm-gen discovered lists to be strong.</span><br><span class="line">  perm_gen()-&gt;ref_processor()-&gt;weak_oops_do(roots);</span><br><span class="line">&#125;</span><br><span class="line">// Global (strong) JNI handles</span><br><span class="line">if (!_process_strong_tasks-&gt;is_task_claimed(SH_PS_JNIHandles_oops_do))</span><br><span class="line">  JNIHandles::oops_do(roots);</span><br><span class="line">// All threads execute this; the individual threads are task groups.</span><br><span class="line">if (ParallelGCThreads &gt; 0) &#123;</span><br><span class="line">  Threads::possibly_parallel_oops_do(roots, code_roots);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  Threads::oops_do(roots, code_roots);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ... 省略</span><br></pre></td></tr></table></figure></p>
<p>这个方法扫描了一定是GC Root的内存区域：</p>
<ul>
<li>Universe类中所引用的一些必须存活的对象 : <code>Universe::oops_do(roots)</code></li>
<li>所有JNI Handles : <code>JNIHandles::oops_do(roots)</code></li>
<li>所有线程的栈 : <code>Threads::oops_do(roots, code_roots)</code></li>
<li>所有被Synchronize锁持有的对象 : <code>ObjectSynchronizer::oops_do(roots)</code></li>
<li>…省略</li>
</ul>
<h5 id="补充-–-HotSpot里面的-Closure"><a href="#补充-–-HotSpot里面的-Closure" class="headerlink" title="补充 – HotSpot里面的 *-Closure"></a>补充 – HotSpot里面的 *-Closure</h5><p>HotSpot VM里有很多以*-Closure方式命名的类。它们其实是封装起来的回调函数。为了让<font color="green"><strong>GC的具体逻辑与对象内部遍历字段的逻辑能松耦合</strong></font>，这部分都是通过回调函数来连接到一起的。</p>
<p>以上面代码的 <code>SharedHeap::process_strong_roots</code> 为例，它是处理根集合的对象的，而这自然包括遍历、处理2部分。</p>
<p>如上面的<code>Universe::oops_do(roots)</code>，<code>Universe</code>会让它的所有对象都调用传入的<code>OopClosure</code>方法。这样就做到遍历与具体逻辑松耦合。</p>
<p>说完了“遍历”，现在要说“处理逻辑”了。看到<code>FastScanClosure::do_oop_work</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">template &lt;class T&gt; inline void FastScanClosure::do_oop_work(T* p) &#123;</span><br><span class="line">  T heap_oop = oopDesc::load_heap_oop(p);</span><br><span class="line">  // Should we copy the obj?</span><br><span class="line">  if (!oopDesc::is_null(heap_oop)) &#123;</span><br><span class="line">    oop obj = oopDesc::decode_heap_oop_not_null(heap_oop);</span><br><span class="line">    if ((HeapWord*)obj &lt; _boundary) &#123;</span><br><span class="line">      assert(!_g-&gt;to()-&gt;is_in_reserved(obj), &quot;Scanning field twice?&quot;);</span><br><span class="line">      oop new_obj = obj-&gt;is_forwarded() ? obj-&gt;forwardee()</span><br><span class="line">                                        : _g-&gt;copy_to_survivor_space(obj);</span><br><span class="line">      oopDesc::encode_store_heap_oop_not_null(p, new_obj);</span><br><span class="line">      if (_gc_barrier) &#123;</span><br><span class="line">        // Now call parent closure</span><br><span class="line">        do_barrier(p);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码的逻辑是：</p>
<ul>
<li>如果这个指针指向的oop对象是没有标记过的，那么将这个oop对象拷贝到to区，并将新oop对象的地址放在老oop对象的markOop里面，表示这个对象已经复制到这个位置了。我们把这个指针称为“转发指针”（Forwarding pointer）。</li>
<li>修改指针的值，让它指向新的oop对象的地址</li>
<li>调用<code>do_barrier</code>方法，这是所谓的“写屏障”（write barrier）</li>
</ul>
<h5 id="复制对象到To区的实现"><a href="#复制对象到To区的实现" class="headerlink" title="复制对象到To区的实现"></a>复制对象到To区的实现</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">oop DefNewGeneration::copy_to_survivor_space(oop old) &#123;</span><br><span class="line">  </span><br><span class="line">  size_t s = old-&gt;size();</span><br><span class="line">  oop obj = NULL;</span><br><span class="line"></span><br><span class="line">  // Try allocating obj in to-space (unless too old)</span><br><span class="line">  if (old-&gt;age() &lt; tenuring_threshold()) &#123;</span><br><span class="line">    obj = (oop) to()-&gt;allocate(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Otherwise try allocating obj tenured</span><br><span class="line">  if (obj == NULL) &#123;</span><br><span class="line">    obj = _next_gen-&gt;promote(old, s);</span><br><span class="line">    if (obj == NULL) &#123;</span><br><span class="line">      handle_promotion_failure(old);</span><br><span class="line">      return old;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // Prefetch beyond obj</span><br><span class="line">    const intx interval = PrefetchCopyIntervalInBytes;</span><br><span class="line">    Prefetch::write(obj, interval);</span><br><span class="line"></span><br><span class="line">    // Copy obj</span><br><span class="line">    Copy::aligned_disjoint_words((HeapWord*)old, (HeapWord*)obj, s);</span><br><span class="line"></span><br><span class="line">    // Increment age if obj still in new generation</span><br><span class="line">    obj-&gt;incr_age();</span><br><span class="line">    age_table()-&gt;add(obj, s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Done, insert forward pointer to obj in this header</span><br><span class="line">  old-&gt;forward_to(obj);</span><br><span class="line"></span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑：</p>
<ul>
<li>判断该对象占用空间是否小于直接移动到老年代的阈值：<ul>
<li>是： <ul>
<li>在to区分配内存，将原对象的数据复制到新对象。</li>
<li>增加对象的复制计数和更新ageTable。</li>
<li>设置原对象的对象头为转发指针(表示该对象已被复制，并指明该对象已经被复制到什么位置)</li>
</ul>
</li>
<li>否： <ul>
<li>尝试在老年代分配内存（将这个对象晋升到老年代）</li>
<li>如果晋升失败，调用<code>DefNewGeneration::handle_promotion_failure</code>方法处理，这个方法主要是把对象oop、markoop入栈，用于后面对象头的恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="补充-–-写屏障"><a href="#补充-–-写屏障" class="headerlink" title="补充 –  写屏障"></a>补充 –  写屏障</h5><p>HotSpot VM的分代式GC需要通过写屏障（write barrier）来维护一个记忆集合（remember set）——记录从old generation到young generation的跨代引用的数据结构。具体在代码中叫做CardTable。在minor GC时，old generation被remember set所记录下的区域会被看作根集合的一部分。而在minor GC过程中，每当有对象晋升到old generation都有可能产生新的跨代引用。</p>
<h5 id="处理更低的分代"><a href="#处理更低的分代" class="headerlink" title="处理更低的分代"></a>处理更低的分代</h5><p><font color="red">这一小段代码在YGC时是不执行的，因为此时的“当前分代”就是新生代，它没有更年轻的分代了！</font><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (younger_gens_as_roots) &#123;</span><br><span class="line">  if (!_gen_process_strong_tasks-&gt;is_task_claimed(GCH_PS_younger_gens)) &#123;</span><br><span class="line">    for (int i = 0; i &lt; level; i++) &#123;</span><br><span class="line">      not_older_gens-&gt;set_generation(_gens[i]);</span><br><span class="line">      _gens[i]-&gt;oop_iterate(not_older_gens);</span><br><span class="line">    &#125;</span><br><span class="line">    not_older_gens-&gt;reset_generation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>遍历所有比当前分代年轻的分代，调用<code>oop_iterate</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void Generation::oop_iterate(OopClosure* cl) &#123;</span><br><span class="line">  GenerationOopIterateClosure blk(cl, _reserved);</span><br><span class="line">  space_iterate(&amp;blk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过使用<code>space_iterate</code>对分代中的各个Sapce进行遍历。<code>space_iterate</code>定义在类<code>Generation</code>，由各个具体分代实现这个方法。</p>
<p>DefNewGeneration的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void DefNewGeneration::space_iterate(SpaceClosure* blk,</span><br><span class="line">                                     bool usedOnly) &#123;</span><br><span class="line">  blk-&gt;do_space(eden());</span><br><span class="line">  blk-&gt;do_space(from());</span><br><span class="line">  blk-&gt;do_space(to());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>分别对eden、from、to区进行处理。处理的逻辑是调用<code>SpaceClosure::do_space</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">virtual void do_space(Space* s) &#123;</span><br><span class="line">    s-&gt;oop_iterate(mr, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因此，对于<code>DefNewGeneration</code>，就是分别调用eden、from、to 3 个Space（它们都是<code>ContiguousSpace</code>）的<code>oop_iterate</code>方法。</p>
<p>这里，Space的oop遍历在另一篇文章关于Space的实现里面会讲。</p>
<p>对于更低的分代，处理逻辑就是将存在于 <strong>DefNewGeneration</strong> 分代的对象，移动到To区。</p>
<h5 id="处理更高的分代"><a href="#处理更高的分代" class="headerlink" title="处理更高的分代"></a>处理更高的分代</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (int i = level+1; i &lt; _n_gens; i++) &#123;</span><br><span class="line">  older_gens-&gt;set_generation(_gens[i]);</span><br><span class="line">  rem_set()-&gt;younger_refs_iterate(_gens[i], older_gens);</span><br><span class="line">  older_gens-&gt;reset_generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里的<code>rem_set()</code>是<code>GenRemSet</code>，这是用于记录老年代到新生代之间对象跨代引用的数据结构。</li>
<li>通过遍历这些oop对象，调用<code>FastScanClosure</code></li>
</ul>
<p>所以，对于更高的分代，也是把存在于<strong>DefNewGeneration</strong> 分代的对象，移动到To区。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>对根集对象（GC Root）标记的过程，分为了3部分处理：</p>
<ul>
<li>当前分代： 扫描一定是GC Root的内存区域。</li>
<li>更低分代： 扫描这些分代的每一个Space</li>
<li>更高分代： 根据<code>GenRemSet</code>数据结构，找到被跨代引用着的对象</li>
</ul>
<p>处理逻辑都是通过<code>FastScanClosure</code>，将对象移动到To区域。现在，就完成了对根集对象的处理，将回收范围限制在<strong>DefNewGeneration</strong>内。</p>
<h4 id="对活跃对象标记"><a href="#对活跃对象标记" class="headerlink" title="对活跃对象标记"></a>对活跃对象标记</h4><p>在上一步，已经将GC Root所直接引用的对象拷贝到To区了，这一步做的就是递归遍历这些对象所引用的对象到To区。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void DefNewGeneration::FastEvacuateFollowersClosure::do_void() &#123;</span><br><span class="line">  do &#123;</span><br><span class="line">    _gch-&gt;oop_since_save_marks_iterate(_level, _scan_cur_or_nonheap,</span><br><span class="line">                                       _scan_older);</span><br><span class="line">  &#125; while (!_gch-&gt;no_allocs_since_save_marks(_level));</span><br><span class="line">  guarantee(_gen-&gt;promo_failure_scan_is_complete(), &quot;Failed to finish scan&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="循环条件"><a href="#循环条件" class="headerlink" title="循环条件"></a>循环条件</h5><p>通过<code>no_allocs_since_save_marks</code>，分别检查当前分代和更高分代其scanned指针_saved_mark_word是否与当前空闲分配指针位置相同，即检查scanned指针是否追上空闲分配指针。</p>
<p>Space的相关指针如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|[ 已分配并且已扫描完的对象 ]|[ 已分配但未扫描完的对象 ]|[ 未分配空间 ]|</span><br><span class="line">^                        ^                      ^             ^</span><br><span class="line">bottom                   scanned                top           end</span><br></pre></td></tr></table></figure></p>
<p>每次扫描一个对象，saved_mark_word（即scanned）会往前移动，期间也有新的对象会被拷贝到to-space，top也会往前移动，直到saved_mark_word追上top，说明to-space的对象都已经遍历完成。</p>
<p>因此，这里是循环判断各个内存代，是否有对象需要扫描，如有，调用<code>oop_since_save_marks_iterate</code>进行处理。否则，退出循环。</p>
<h5 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h5><p>对每一个分代遍历：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void GenCollectedHeap::                                                 \</span><br><span class="line">oop_since_save_marks_iterate(int level,                                 \</span><br><span class="line">                             OopClosureType* cur,                       \</span><br><span class="line">                             OopClosureType* older) &#123;                   \</span><br><span class="line">  _gens[level]-&gt;oop_since_save_marks_iterate##nv_suffix(cur);           \</span><br><span class="line">  for (int i = level+1; i &lt; n_gens(); i++) &#123;                            \</span><br><span class="line">    _gens[i]-&gt;oop_since_save_marks_iterate##nv_suffix(older);           \</span><br><span class="line">  &#125;                                                                     \</span><br><span class="line">  perm_gen()-&gt;oop_since_save_marks_iterate##nv_suffix(older);           \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看到DefNewGeneration的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void DefNewGeneration::                                         \</span><br><span class="line">oop_since_save_marks_iterate##nv_suffix(OopClosureType* cl) &#123;   \</span><br><span class="line">  cl-&gt;set_generation(this);                                     \</span><br><span class="line">  eden()-&gt;oop_since_save_marks_iterate##nv_suffix(cl);          \</span><br><span class="line">  to()-&gt;oop_since_save_marks_iterate##nv_suffix(cl);            \</span><br><span class="line">  from()-&gt;oop_since_save_marks_iterate##nv_suffix(cl);          \</span><br><span class="line">  cl-&gt;reset_generation();                                       \</span><br><span class="line">  save_marks();                                                 \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实方法名字就说明了，“遍历处理从 scaned指针到top之间的对象”。</p>
<p>具体逻辑是分别调用了eden、from、to的<code>oop_since_save_marks_iterate</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">void ContiguousSpace::                                                    \</span><br><span class="line">oop_since_save_marks_iterate##nv_suffix(OopClosureType* blk) &#123;            \</span><br><span class="line">  HeapWord* t;                                                            \</span><br><span class="line">  HeapWord* p = saved_mark_word();                                        \</span><br><span class="line">  assert(p != NULL, &quot;expected saved mark&quot;);                               \</span><br><span class="line">                                                                          \</span><br><span class="line">  const intx interval = PrefetchScanIntervalInBytes;                      \</span><br><span class="line">  do &#123;                                                                    \</span><br><span class="line">    t = top();                                                            \</span><br><span class="line">    while (p &lt; t) &#123;                                                       \</span><br><span class="line">      Prefetch::write(p, interval);                                       \</span><br><span class="line">      debug_only(HeapWord* prev = p);                                     \</span><br><span class="line">      oop m = oop(p);                                                     \</span><br><span class="line">      p += m-&gt;oop_iterate(blk);                                           \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125; while (t &lt; top());                                                    \</span><br><span class="line">                                                                          \</span><br><span class="line">  set_saved_mark_word(p);                                                 \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，同样是调用<code>FastScanClosure</code>进行处理。</p>
<h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>对活跃对象标记这一步，就是将对象（从上一步得到的对象所引用着的对象）移动到To区。<br>在这个过程中，需要遍历更高的内存代，因为对象在复制的过程中，是可能晋升的。</p>
<h4 id="处理引用"><a href="#处理引用" class="headerlink" title="处理引用"></a>处理引用</h4><p>先跳过.</p>
<h4 id="处理晋升成功"><a href="#处理晋升成功" class="headerlink" title="处理晋升成功"></a>处理晋升成功</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">if (!promotion_failed()) &#123;</span><br><span class="line">  // Swap the survivor spaces.</span><br><span class="line">  eden()-&gt;clear(SpaceDecorator::Mangle);</span><br><span class="line">  from()-&gt;clear(SpaceDecorator::Mangle);</span><br><span class="line">  if (ZapUnusedHeapArea) &#123;</span><br><span class="line">    // This is now done here because of the piece-meal mangling which</span><br><span class="line">    // can check for valid mangling at intermediate points in the</span><br><span class="line">    // collection(s).  When a minor collection fails to collect</span><br><span class="line">    // sufficient space resizing of the young generation can occur</span><br><span class="line">    // an redistribute the spaces in the young generation.  Mangle</span><br><span class="line">    // here so that unzapped regions don&apos;t get distributed to</span><br><span class="line">    // other spaces.</span><br><span class="line">    to()-&gt;mangle_unused_area();</span><br><span class="line">  &#125;</span><br><span class="line">  swap_spaces();</span><br><span class="line"></span><br><span class="line">  assert(to()-&gt;is_empty(), &quot;to space should be empty now&quot;);</span><br><span class="line"></span><br><span class="line">  // Set the desired survivor size to half the real survivor space</span><br><span class="line">  _tenuring_threshold =</span><br><span class="line">    age_table()-&gt;compute_tenuring_threshold(to()-&gt;capacity()/HeapWordSize);</span><br><span class="line"></span><br><span class="line">  // A successful scavenge should restart the GC time limit count which is</span><br><span class="line">  // for full GC&apos;s.</span><br><span class="line">  AdaptiveSizePolicy* size_policy = gch-&gt;gen_policy()-&gt;size_policy();</span><br><span class="line">  size_policy-&gt;reset_gc_overhead_limit_count();</span><br><span class="line">  if (PrintGC &amp;&amp; !PrintGCDetails) &#123;</span><br><span class="line">    gch-&gt;print_heap_change(gch_prev_used);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(!gch-&gt;incremental_collection_failed(), &quot;Should be clear&quot;);</span><br></pre></td></tr></table></figure>
<p>如果没有对象发生晋升失败，执行下面的逻辑：</p>
<ul>
<li>既然所有对象都晋升成功了，说明存活对象都转移到了to区域或老年代，则通过clear方法清空eden和from区；</li>
<li>通过<code>swap_spaces</code>方法交换from和to区域。</li>
<li>还会将Eden的<code>_next_compaction_space</code>指向from，而from的为NUll。Full GC时会使用这个指针对Space压缩。即表示压缩eden区和from区（原To区）。</li>
</ul>
<h4 id="处理晋升失败"><a href="#处理晋升失败" class="headerlink" title="处理晋升失败"></a>处理晋升失败</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">else &#123;</span><br><span class="line">  assert(_promo_failure_scan_stack.is_empty(), &quot;post condition&quot;);</span><br><span class="line">  _promo_failure_scan_stack.clear(true); // Clear cached segments.</span><br><span class="line"></span><br><span class="line">  remove_forwarding_pointers();</span><br><span class="line">  if (PrintGCDetails) &#123;</span><br><span class="line">    gclog_or_tty-&gt;print(&quot; (promotion failed) &quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // Add to-space to the list of space to compact</span><br><span class="line">  // when a promotion failure has occurred.  In that</span><br><span class="line">  // case there can be live objects in to-space</span><br><span class="line">  // as a result of a partial evacuation of eden</span><br><span class="line">  // and from-space.</span><br><span class="line">  swap_spaces();   // For uniformity wrt ParNewGeneration.</span><br><span class="line">  from()-&gt;set_next_compaction_space(to());</span><br><span class="line">  gch-&gt;set_incremental_collection_failed();</span><br><span class="line"></span><br><span class="line">  // Inform the next generation that a promotion failure occurred.</span><br><span class="line">  _next_gen-&gt;promotion_failure_occurred();</span><br><span class="line"></span><br><span class="line">  // Reset the PromotionFailureALot counters.</span><br><span class="line">  NOT_PRODUCT(Universe::heap()-&gt;reset_promotion_should_fail();)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行下面逻辑：</p>
<ul>
<li>通过<code>remove_forwarding_pointers</code>恢复晋升失败对象的markOop。</li>
<li>将from和to区进行互换，还将设置to区设置为from区的下一个压缩区域。即表示eden、from、to都需要压缩。</li>
<li>设置新生代的收集失败标记</li>
<li>通知下一内存分代（老年代）发生了晋升失败</li>
</ul>
<p>在对象发生晋升失败时，会把该对象的oop和markoop分别保存在<code>_objs_with_preserved_marks</code>和<code>_preserved_marks_of_objs</code>这2个栈。同时将对象头的“转发指针”指向自身（应该是为了避免重复遍历到这个对象）。</p>
<p><code>remove_forwarding_pointers</code>做的就是从2个栈取出oop对象和对应的markOop，然后恢复对象头。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>DefNewGeneration的YGC流程为：</p>
<ol>
<li>将GC Root直接引用的对象拷贝到To区</li>
<li>遍历上一步的对象，拷贝这些对象所引用的对象（称为活跃对象）到To区</li>
<li>还要处理自然晋升（对象年龄大于阀值导致的）和提前晋升（To区域空间不足）</li>
</ol>
<p>这部分的代码分为7个部分：</p>
<ul>
<li>检查</li>
<li>准备工作</li>
<li>对根集对象标记（GC Root），其中又细分为3部分：<ul>
<li>处理当前分代（扫描一定是GC Root的内存区域）</li>
<li>处理更年轻的分代（由于现在是YGC，没有更年轻的分代）</li>
<li>处理更年老的分代，借助<code>GenRemSet</code>，处理被老年代对象跨代引用着的对象</li>
</ul>
</li>
<li>对活跃对象标记<ul>
<li>遍历每一个分代的每一个Space，直到没有未被扫描的对象</li>
<li>每个Space根据指针<code>scanned</code>是否“追上”<code>top</code>可以知道有没有未被扫描的对象。</li>
</ul>
</li>
<li>处理引用 (先跳过)</li>
<li>处理晋升成功</li>
<li>处理晋升失败</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/17/JVM_GC_SerialGC/" rel="next" title="Serial GC的minor GC算法">
                <i class="fa fa-chevron-left"></i> Serial GC的minor GC算法
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/19/JVM_GC_TenuredGeneration/" rel="prev" title="HotSpot老年代TenuredGeneration的实现">
                HotSpot老年代TenuredGeneration的实现 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JH_Chen</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">69</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#DefNewGeneration的定义"><span class="nav-number">1.</span> <span class="nav-text">DefNewGeneration的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DefNewGeneration的初始化"><span class="nav-number">2.</span> <span class="nav-text">DefNewGeneration的初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DefNewGeneration的GC过程"><span class="nav-number">3.</span> <span class="nav-text">DefNewGeneration的GC过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检查"><span class="nav-number">3.1.</span> <span class="nav-text">检查</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备工作"><span class="nav-number">3.2.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对根集对象标记"><span class="nav-number">3.3.</span> <span class="nav-text">对根集对象标记</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#处理当前分代"><span class="nav-number">3.3.1.</span> <span class="nav-text">处理当前分代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#补充-–-HotSpot里面的-Closure"><span class="nav-number">3.3.2.</span> <span class="nav-text">补充 – HotSpot里面的 *-Closure</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#复制对象到To区的实现"><span class="nav-number">3.3.3.</span> <span class="nav-text">复制对象到To区的实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#补充-–-写屏障"><span class="nav-number">3.3.4.</span> <span class="nav-text">补充 –  写屏障</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理更低的分代"><span class="nav-number">3.3.5.</span> <span class="nav-text">处理更低的分代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理更高的分代"><span class="nav-number">3.3.6.</span> <span class="nav-text">处理更高的分代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结"><span class="nav-number">3.3.7.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#对活跃对象标记"><span class="nav-number">3.4.</span> <span class="nav-text">对活跃对象标记</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#循环条件"><span class="nav-number">3.4.1.</span> <span class="nav-text">循环条件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#处理"><span class="nav-number">3.4.2.</span> <span class="nav-text">处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结-1"><span class="nav-number">3.4.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理引用"><span class="nav-number">3.5.</span> <span class="nav-text">处理引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理晋升成功"><span class="nav-number">3.6.</span> <span class="nav-text">处理晋升成功</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理晋升失败"><span class="nav-number">3.7.</span> <span class="nav-text">处理晋升失败</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">3.8.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JH_Chen</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.1</div>






        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
