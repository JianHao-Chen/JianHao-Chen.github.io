<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="学习JVM源码Synchronized锁部分，写了如下几篇文章：  Synchronized底层实现—-概述 Synchronized底层实现—-偏向锁（本文） Synchronized底层实现—-轻量级锁 Synchronized底层实现—-重量级锁">
<meta name="keywords" content="JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="Synchronized底层实现—-偏向锁">
<meta property="og:url" content="http://yoursite.com/2019/06/24/JVM_Synchronized_Bias/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="学习JVM源码Synchronized锁部分，写了如下几篇文章：  Synchronized底层实现—-概述 Synchronized底层实现—-偏向锁（本文） Synchronized底层实现—-轻量级锁 Synchronized底层实现—-重量级锁">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-08T08:23:47.359Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Synchronized底层实现—-偏向锁">
<meta name="twitter:description" content="学习JVM源码Synchronized锁部分，写了如下几篇文章：  Synchronized底层实现—-概述 Synchronized底层实现—-偏向锁（本文） Synchronized底层实现—-轻量级锁 Synchronized底层实现—-重量级锁">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/06/24/JVM_Synchronized_Bias/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Synchronized底层实现—-偏向锁 | Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/JVM_Synchronized_Bias/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="JH_Chen">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Synchronized底层实现—-偏向锁

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-06-24 08:55:00" itemprop="dateCreated datePublished" datetime="2019-06-24T08:55:00+08:00">2019-06-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-08 16:23:47" itemprop="dateModified" datetime="2019-07-08T16:23:47+08:00">2019-07-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>学习JVM源码Synchronized锁部分，写了如下几篇文章：</p>
<ul>
<li>Synchronized底层实现—-概述</li>
<li>Synchronized底层实现—-偏向锁（本文）</li>
<li>Synchronized底层实现—-轻量级锁</li>
<li>Synchronized底层实现—-重量级锁</li>
</ul>
<a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>偏向锁的实现，其实就是找字节码<code>monitorenter</code>的实现，有以下2个地方：</p>
<ul>
<li>在 bytecodeInterpreter：用于c++解释器</li>
<li>在 templateInterpreter：用于模板解释器</li>
</ul>
<p>由于只有少数版本的HotSpot在用 c++ 解释器，其他都用模板解释器，按道理是直接看<code>templateInterpreter</code>的实现。只是它们两者的逻辑是差不多的，而<code>bytecodeInterpreter</code> 的实现是c++ 代码，而<code>templateInterpreter</code>的实现是汇编代码，因此，本文选<code>bytecodeInterpreter</code>的实现。</p>
<h3 id="偏向锁获取"><a href="#偏向锁获取" class="headerlink" title="偏向锁获取"></a>偏向锁获取</h3><p>代码看到<code>bytecodeInterpreter.cpp</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">CASE(_monitorenter): &#123;</span><br><span class="line">  // STACK_OBJECT 就是以（栈顶地址 + 偏移）的方式取出对象</span><br><span class="line">  // 此处，取出的对象就是“锁对象”</span><br><span class="line">  oop lockee = STACK_OBJECT(-1);</span><br><span class="line">  // derefing&apos;s lockee ought to provoke implicit null check</span><br><span class="line">  CHECK_NULL(lockee);</span><br><span class="line">  </span><br><span class="line">  // ## 1. 在栈中找到一个 “最近”的 Lock Record（按照从栈顶往下的方向找），有2种情况：</span><br><span class="line">  // (1) Lock Record 是“空闲”的，</span><br><span class="line">  // (2) 已分配给当前对象（即当前属于【锁重入】的情况）</span><br><span class="line">  BasicObjectLock* limit = istate-&gt;monitor_base();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();</span><br><span class="line">  BasicObjectLock* entry = NULL;</span><br><span class="line">  while (most_recent != limit ) &#123;</span><br><span class="line">    if (most_recent-&gt;obj() == NULL) entry = most_recent;</span><br><span class="line">    else if (most_recent-&gt;obj() == lockee) break;</span><br><span class="line">    most_recent++;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // 找到 Lock Record</span><br><span class="line">  if (entry != NULL) &#123;</span><br><span class="line">    // 对 Lock Record 的 obj 字段赋值</span><br><span class="line">    entry-&gt;set_obj(lockee);</span><br><span class="line">    int success = false;</span><br><span class="line">    uintptr_t epoch_mask_in_place = (uintptr_t)markOopDesc::epoch_mask_in_place;</span><br><span class="line">    </span><br><span class="line">    markOop mark = lockee-&gt;mark();</span><br><span class="line">    intptr_t hash = (intptr_t) markOopDesc::no_hash;</span><br><span class="line">    </span><br><span class="line">    // ## 2. 根据 mark word 的最低3位是否“101”，判断是否使用偏向锁</span><br><span class="line">    if (mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">      uintptr_t thread_ident;</span><br><span class="line">      uintptr_t anticipated_bias_locking_value;</span><br><span class="line">      thread_ident = (uintptr_t)istate-&gt;thread();</span><br><span class="line">      </span><br><span class="line">      // ## 3. 对偏向锁相关的bit进行计算，分为如下4步：</span><br><span class="line">      //  （1）将 prototype_header 与线程ID “相或” 操作，得到：【线程ID + prototype_header 中的（epoch + 分代年龄 + 偏向锁标志 +锁标志位）】，分代年龄为 0。</span><br><span class="line">      //  （2）将（1）的结果与锁对象的 markOop 进行“异或”，相等的位全部被置为0，只剩下不相等的位。</span><br><span class="line">      //  （3）对 age_mask_in_place “取反”，得到一个 MarkWord 结构的数组，除了分代年龄的4位为0，其他位为1。</span><br><span class="line">      //  （4）将（2）和（3）的结果进行 “相与”操作，把（2）的结果关于分代年龄的bit忽略掉。</span><br><span class="line">      anticipated_bias_locking_value =</span><br><span class="line">             (((uintptr_t)lockee-&gt;klass()-&gt;prototype_header() |thread_ident) ^ (uintptr_t)mark) &amp;</span><br><span class="line">             ~((uintptr_t) markOopDesc::age_mask_in_place);</span><br><span class="line">    </span><br><span class="line">      // ## 4. anticipated_bias_locking_value = 0，表示：</span><br><span class="line">      //  （1）锁对象的 Mark Word的 线程ID 指向当前线程</span><br><span class="line">      //  （2）锁对象的 Mark Word的 Epoch == klass 的 Epoch</span><br><span class="line">      // 结论是 【当前线程获得偏向锁】，什么都不用做，返回</span><br><span class="line">      if  (anticipated_bias_locking_value == 0) &#123;</span><br><span class="line">        // already biased towards this thread, nothing to do</span><br><span class="line">        if (PrintBiasedLockingStatistics) &#123;</span><br><span class="line">          (* BiasedLocking::biased_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">        success = true;</span><br><span class="line">      &#125;</span><br><span class="line">      // 来到这里，表示【锁对象并没有偏向当前线程】，判断是否需要【撤销锁对象的偏向】。</span><br><span class="line">     </span><br><span class="line">      // ## 5. 将 anticipated_bias_locking_value 与 biased_lock_mask_in_place（111）相与。</span><br><span class="line">      //  （1）如果结果 != 0，说明 locking_value 的后3位存在不为0的位</span><br><span class="line">      //  （2）说明之前 “异或” 操作时，类的 prototype_header 与锁对象 markOop 的后3位不相等</span><br><span class="line">      //  （3）代码走到这里，markOop 的后3位一定是 “101”（即偏向模式）</span><br><span class="line">      //  （4）就是类的 prototype_header 的后3位不是 “101”，即【对象所属类不再支持偏向】，发生了 【bulk_revoke】。</span><br><span class="line">      // 结论是 【需要对当前对象进行偏向锁的撤销】</span><br><span class="line">      else if ((anticipated_bias_locking_value &amp; markOopDesc::biased_lock_mask_in_place) != 0) &#123;</span><br><span class="line">        // try revoke bias</span><br><span class="line">        markOop header = lockee-&gt;klass()-&gt;prototype_header();</span><br><span class="line">        if (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        // 利用 CAS 操作将 mark word 替换为 klass 中的 mark word</span><br><span class="line">        if (Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), mark) == mark) &#123;</span><br><span class="line">          if (PrintBiasedLockingStatistics)</span><br><span class="line">            (*BiasedLocking::revoked_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 来到这里，表示【类还支持偏向锁】，需要【判断当前对象的epoch】是否合法，如果不合法，需要进行【重偏向】</span><br><span class="line">      </span><br><span class="line">      ## 6. 将 locking_value 与 epoch_mask_in_place 相与，检查类的 prototype_header 中 epoch 是否为0。</span><br><span class="line">      //  （1）如果结果 != 0，说明类的 prototype_header 中 epoch 和对象 markOop 的 epoch 不相等。</span><br><span class="line">      //  （2）说明类在对象分配后发生过 【bulk_rebais】，所以之前对象的偏向就无效了</span><br><span class="line">      //  （3）每次发生【bulk_rebaise】,类的 prototype header 中的 epoch 都会+1</span><br><span class="line">      // 结论是：需要进行【重偏向】</span><br><span class="line">      else if ((anticipated_bias_locking_value &amp; epoch_mask_in_place) !=0) &#123;</span><br><span class="line">        // try rebias</span><br><span class="line">        // 构造一个偏向当前线程的mark word</span><br><span class="line">        markOop new_header = (markOop) ( (intptr_t) lockee-&gt;klass()-&gt;prototype_header() | thread_ident);</span><br><span class="line">        if (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          new_header = new_header-&gt;copy_set_hash(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        // CAS替换对象头的mark word</span><br><span class="line">        if (Atomic::cmpxchg_ptr((void*)new_header, lockee-&gt;mark_addr(), mark) == mark) &#123;</span><br><span class="line">          if (PrintBiasedLockingStatistics)</span><br><span class="line">            (* BiasedLocking::rebiased_lock_entry_count_addr())++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 重偏向失败，代表存在多线程竞争，则调用monitorenter方法进行锁升级</span><br><span class="line">        else &#123;</span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = true;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      // 来到这里，表示走到这里说明当前要么偏向别的线程，要么是匿名偏向（即没有偏向任何线程）。可以尝试获取锁。</span><br><span class="line">      </span><br><span class="line">      else &#123;</span><br><span class="line">      </span><br><span class="line">        // try to bias towards thread in case object is anonymously biased</span><br><span class="line">        // 构建一个匿名偏向的mark word，尝试用 CAS 指令替换掉锁对象的 mark word</span><br><span class="line">        markOop header = (markOop) ((uintptr_t) mark &amp; ((uintptr_t)markOopDesc::biased_lock_mask_in_place |</span><br><span class="line">                                                              (uintptr_t)markOopDesc::age_mask_in_place |</span><br><span class="line">                                                              epoch_mask_in_place));</span><br><span class="line">        if (hash != markOopDesc::no_hash) &#123;</span><br><span class="line">          header = header-&gt;copy_set_hash(hash);</span><br><span class="line">        &#125;</span><br><span class="line">        markOop new_header = (markOop) ((uintptr_t) headerthread_ident);</span><br><span class="line">        if (Atomic::cmpxchg_ptr((void*)new_header, lockee-&gt;mark_addr(), header) == header) &#123;</span><br><span class="line">          if (PrintBiasedLockingStatistics)</span><br><span class="line">            BiasedLocking::anonymously_biased_lock_entry_count_add++;</span><br><span class="line">        &#125;</span><br><span class="line">        else &#123;</span><br><span class="line">          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entryhandle_exception);</span><br><span class="line">        &#125;</span><br><span class="line">        success = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // traditional lightweight locking</span><br><span class="line">    // 这里开始是轻量级锁的逻辑了，省略</span><br><span class="line">    if (!success) &#123;</span><br><span class="line">        // ... </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="偏向锁撤销"><a href="#偏向锁撤销" class="headerlink" title="偏向锁撤销"></a>偏向锁撤销</h3><p><font color="orange">撤销是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态</font>。</p>
<p>前面提到过，当获取偏向锁失败时，会进入到<code>InterpreterRuntime::monitorenter</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter(JavaThread* thread, BasicObjectLock* elem))</span><br><span class="line">  // ... 省略</span><br><span class="line">  if (UseBiasedLocking) &#123;</span><br><span class="line">    // Retry fast entry if bias is revoked to avoid unnecessary inflation</span><br><span class="line">    ObjectSynchronizer::fast_enter(h_obj, elem-&gt;lock(), true, CHECK);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ObjectSynchronizer::slow_enter(h_obj, elem-&gt;lock(), CHECK);</span><br><span class="line">  &#125;</span><br><span class="line">IRT_END</span><br></pre></td></tr></table></figure></p>
<p>如果开启偏向锁，进入<code>fast_enter</code>流程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void ObjectSynchronizer::fast_enter(Handle obj, BasicLock* lock, bool attempt_rebias, TRAPS) &#123;</span><br><span class="line">  if (UseBiasedLocking) &#123;</span><br><span class="line">    if (!SafepointSynchronize::is_at_safepoint()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond =BiasedLocking::revoke_and_rebias(obj,  attempt_rebias, THREAD);</span><br><span class="line">      if (cond == BiasedLocking::BIAS_REVOKED_AND_REBIASED) &#123;</span><br><span class="line">        return;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      assert(!attempt_rebias, &quot;can not rebias toward VM thread&quot;);</span><br><span class="line">      BiasedLocking::revoke_at_safepoint(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    assert(!obj-&gt;mark()-&gt;has_bias_pattern(), &quot;biases should be revoked by  now&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  slow_enter (obj, lock, THREAD) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果不在 safepoint ，那么应该是Java线程，尝试 <font color="green"><strong>撤销并重偏向锁</strong></font>。<ul>
<li>如果成功，直接返回。</li>
<li>否则，进入到<code>slow_enter</code>流程。</li>
</ul>
</li>
<li>如果在 safepoint ，那么应该是VM线程，尝试 <font color="green"><strong>撤销偏向锁</strong></font>。</li>
</ul>
<p>看到<code>revoke_and_rebias</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">BiasedLocking::Condition BiasedLocking::revoke_and_rebias(Handle obj, bool attempt_rebias, TRAPS) &#123;</span><br><span class="line"></span><br><span class="line">  assert(!SafepointSynchronize::is_at_safepoint(), &quot;must not be called while at safepoint&quot;);</span><br><span class="line">  </span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  </span><br><span class="line">  // ## 1. 如果当前锁是【匿名偏向】 并且 【不是要获取偏向锁】</span><br><span class="line">  // --------&gt;  如锁对象的hashcode方法被调用会出现这种情况，需要撤销偏向锁。 &lt;-----</span><br><span class="line">  if (mark-&gt;is_biased_anonymously() &amp;&amp; !attempt_rebias) &#123;</span><br><span class="line">    markOop biased_value       = mark;</span><br><span class="line">    markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span><br><span class="line">    markOop res_mark = (markOop) Atomic::cmpxchg_ptr(unbiased_prototype, obj-&gt;mark_addr(), mark);</span><br><span class="line">    if (res_mark == biased_value) &#123;</span><br><span class="line">      return BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ## 2. 如果锁对象开启偏向锁</span><br><span class="line">  else if (mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">    Klass* k = obj-&gt;klass();</span><br><span class="line">    markOop prototype_header = k-&gt;prototype_header();</span><br><span class="line">    </span><br><span class="line">    // ## 2.1 如果对应的 klass 关闭了偏向锁，即发生了 【bulk_revoke】</span><br><span class="line">    // 这时，只需要通过 CAS 设置对象的 Mark Word（为 klass 的 mark word）。不需要记录锁撤销。</span><br><span class="line">    // 即使 CAS 操作失败，说明【有其他线程将它撤销了】，于是直接返回。</span><br><span class="line">    if (!prototype_header-&gt;has_bias_pattern()) &#123;</span><br><span class="line">      markOop biased_value       = mark;</span><br><span class="line">      markOop res_mark = (markOop) Atomic::cmpxchg_ptr(prototype_header, obj-&gt;mark_addr(), mark);</span><br><span class="line">      assert(!(*(obj-&gt;mark_addr()))-&gt;has_bias_pattern(), &quot;even if we raced, should still be revoked&quot;);</span><br><span class="line">      return BIAS_REVOKED;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ## 2.2 如果锁对象的epoch过期了，意味着这个对象的状态是【未偏向】的</span><br><span class="line">    // 因此可以直接通过 CAS 操作设置对象的 Mark Word。不需要记录锁撤销。</span><br><span class="line">    else if (prototype_header-&gt;bias_epoch() != mark-&gt;bias_epoch()) &#123;</span><br><span class="line">    </span><br><span class="line">      // ## 2.2.1 将锁重偏向为当前线程</span><br><span class="line">      if (attempt_rebias) &#123;</span><br><span class="line">        assert(THREAD-&gt;is_Java_thread(), &quot;&quot;);</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop rebiased_prototype = markOopDesc::encode((JavaThread*) THREAD, mark-&gt;age(), prototype_header-&gt;bias_epoch());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::cmpxchg_ptr(rebiased_prototype, obj-&gt;mark_addr(), mark);</span><br><span class="line">        if (res_mark == biased_value) &#123;</span><br><span class="line">          return BIAS_REVOKED_AND_REBIASED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; </span><br><span class="line">      // ## 2.2.2 将锁撤销</span><br><span class="line">      else &#123;</span><br><span class="line">        markOop biased_value       = mark;</span><br><span class="line">        markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(mark-&gt;age());</span><br><span class="line">        markOop res_mark = (markOop) Atomic::cmpxchg_ptr(unbiased_prototype, obj-&gt;mark_addr(), mark);</span><br><span class="line">        if (res_mark == biased_value) &#123;</span><br><span class="line">          return BIAS_REVOKED;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // ## 3. 更新偏向锁撤销的次数（与批量重偏向与批量撤销相关）</span><br><span class="line">  HeuristicsResult heuristics = update_heuristics(obj(), attempt_rebias);</span><br><span class="line">  // ## 3.1 当前锁对象状态为【不可偏向】</span><br><span class="line">  if (heuristics == HR_NOT_BIASED) &#123;</span><br><span class="line">    return NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ## 3.2 撤销单个线程获得的偏向锁</span><br><span class="line">  else if (heuristics == HR_SINGLE_REVOKE) &#123;</span><br><span class="line">    Klass *k = obj-&gt;klass();</span><br><span class="line">    markOop prototype_header = k-&gt;prototype_header();</span><br><span class="line">    </span><br><span class="line">    // ## 3.2.1 如果撤销的是当前线程自己的偏向锁（比如调用 hashcode()方法导致）</span><br><span class="line">    // 只需要直接修改锁对象的 Mark Word 即可。 </span><br><span class="line">    if (mark-&gt;biased_locker() == THREAD &amp;&amp;</span><br><span class="line">        prototype_header-&gt;bias_epoch() == mark-&gt;bias_epoch()) &#123;</span><br><span class="line">      BiasedLocking::Condition cond = revoke_bias(obj(), false, false, (JavaThread*) THREAD);</span><br><span class="line">      ((JavaThread*) THREAD)-&gt;set_cached_monitor_info(NULL);</span><br><span class="line">      assert(cond == BIAS_REVOKED, &quot;why not?&quot;);</span><br><span class="line">      return cond;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // ## 3.2.2 如果撤销的是其他线程拥有的偏向锁，就需要通过VM线程撤销偏向锁</span><br><span class="line">    else &#123;</span><br><span class="line">      VM_RevokeBias revoke(&amp;obj, (JavaThread*) THREAD);</span><br><span class="line">      VMThread::execute(&amp;revoke);</span><br><span class="line">      return revoke.status_code();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  assert((heuristics == HR_BULK_REVOKE) ||</span><br><span class="line">         (heuristics == HR_BULK_REBIAS), &quot;?&quot;);</span><br><span class="line">         </span><br><span class="line">  // ## 4. 通过VM线程执行【批量撤销、批量重偏向】的逻辑</span><br><span class="line">  VM_BulkRevokeBias bulk_revoke(&amp;obj, (JavaThread*) THREAD,</span><br><span class="line">                                (heuristics == HR_BULK_REBIAS),</span><br><span class="line">                                attempt_rebias);</span><br><span class="line">  VMThread::execute(&amp;bulk_revoke);</span><br><span class="line">  return bulk_revoke.status_code();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的逻辑可以总结为：</p>
<ul>
<li>之所以会进入到这个<code>revoke_and_rebias</code>方法，是由于获取偏向锁失败了（出现线程竞争），于是需要撤销偏向锁。（由于支持<strong>批量撤销、批量重偏向</strong>的关系，使得这个方法变复杂了）</li>
<li>先处理以下情况，它们都是不需要记录锁撤销的：<ul>
<li>如果 klass 关闭了偏向锁，即发生了【批量撤销】：设置对象mark word为klass的值，然后返回。</li>
<li>锁对象的epoch过期，即锁对象是未偏向的：只要通过CAS设置对象的 Mark Word（将锁重偏向或将锁撤销），然后返回</li>
</ul>
</li>
<li>记录偏向锁撤销的次数，根据撤销次数与相关阈值，作如下处理：<ul>
<li>撤销单个线程获得的偏向锁<ul>
<li>如果是当前线程自己的偏向锁，直接执行偏向锁撤销逻辑</li>
<li>如果是其他线程的偏向锁，需要由VM线程执行</li>
</ul>
</li>
<li>批量撤销、批量重偏向：由VM线程执行</li>
</ul>
</li>
</ul>
<p>撤销偏向锁的逻辑在 <strong>revoke_bias</strong> 这个方法实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">static BiasedLocking::Condition revoke_bias(oop obj, bool allow_rebias, bool is_bulk, JavaThread* requesting_thread) &#123;</span><br><span class="line"></span><br><span class="line">  markOop mark = obj-&gt;mark();</span><br><span class="line">  if (!mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">    return BiasedLocking::NOT_BIASED;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  uint age = mark-&gt;age();</span><br><span class="line">  // 构建两个mark word，一个是匿名偏向模式（101），一个是无锁模式（001）</span><br><span class="line">  markOop   biased_prototype = markOopDesc::biased_locking_prototype()-&gt;set_age(age);</span><br><span class="line">  markOop unbiased_prototype = markOopDesc::prototype()-&gt;set_age(age);</span><br><span class="line"></span><br><span class="line">  JavaThread* biased_thread = mark-&gt;biased_locker();</span><br><span class="line">  </span><br><span class="line">  // ## 1. 匿名偏向（例如调用 hashCode 方法会来到这里）</span><br><span class="line">  if (biased_thread == NULL) &#123;</span><br><span class="line">  </span><br><span class="line">    // ## 1.1 如果不允许重偏向，则将对象的mark word设置为无锁模式</span><br><span class="line">    if (!allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // ## 2. 判断拥有偏向锁的线程是否存活</span><br><span class="line">  bool thread_is_alive = false;</span><br><span class="line">  // ## 2.1 如果是当前线程，自然是存活的</span><br><span class="line">  if (requesting_thread == biased_thread) &#123;</span><br><span class="line">    thread_is_alive = true;</span><br><span class="line">  &#125;</span><br><span class="line">  // ## 2.2 遍历JVM的所有线程去找</span><br><span class="line">  else &#123;</span><br><span class="line">    for (JavaThread* cur_thread = Threads::first(); cur_thread != NULL; cur_thread = cur_thread-&gt;next()) &#123;</span><br><span class="line">      if (cur_thread == biased_thread) &#123;</span><br><span class="line">        thread_is_alive = true;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ## 3. 如果线程已经不存活了</span><br><span class="line">  if (!thread_is_alive) &#123;</span><br><span class="line">    // 允许重偏向则将对象mark word设置为匿名偏向状态，否则设置为无锁状态</span><br><span class="line">    if (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">    return BiasedLocking::BIAS_REVOKED;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  // ## 4. 线程还存活，需要遍历线程栈中所有的【Lock Record】</span><br><span class="line">  </span><br><span class="line">  // ## 4.1 从线程的栈帧中取出 monitors 数组</span><br><span class="line">  GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(biased_thread);</span><br><span class="line">  BasicLock* highest_lock = NULL;</span><br><span class="line">  for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) &#123;</span><br><span class="line">    MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span><br><span class="line">    </span><br><span class="line">    // ## 4.2 如果找到对应的 Lock Record，说明【这个线程还在执行同步块中的代码】</span><br><span class="line">    if (mon_info-&gt;owner() == obj) &#123;</span><br><span class="line">      </span><br><span class="line">      // ## 4.3 【需要升级为轻量级锁】，直接修改此 Lock Record</span><br><span class="line">      // 处理锁重入的case，需注意2点：</span><br><span class="line">      //   （A）这里的 for 循环是对每一个 Lock Record 都这样操作的（没有 break）。</span><br><span class="line">      //   （B）将 Lock Record 的【 Displaced Mark Word】设置为null</span><br><span class="line">      //   （B）第一个Lock Record会在下面的代码中再处理</span><br><span class="line">      markOop mark = markOopDesc::encode((BasicLock*) NULL);</span><br><span class="line">      highest_lock = mon_info-&gt;lock();</span><br><span class="line">      highest_lock-&gt;set_displaced_header(mark);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  if (highest_lock != NULL) &#123;</span><br><span class="line">    // ## 4.4 修改第一个Lock Record为无锁状态，然后将obj的mark word设置为指向该Lock Record的指针</span><br><span class="line">    highest_lock-&gt;set_displaced_header(unbiased_prototype);</span><br><span class="line">    obj-&gt;release_set_mark(markOopDesc::encode(highest_lock));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ## 5. 偏向线程已经不在同步块中了，将偏向锁设置为【匿名偏向】或【无锁】状态</span><br><span class="line">  else &#123;</span><br><span class="line">    if (allow_rebias) &#123;</span><br><span class="line">      obj-&gt;set_mark(biased_prototype);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Store the unlocked value into the object&apos;s header.</span><br><span class="line">      obj-&gt;set_mark(unbiased_prototype);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  return BiasedLocking::BIAS_REVOKED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>小结</strong>：revoke_bias–撤销偏向锁<br>撤销偏向锁的逻辑：</p>
<ol>
<li>查看偏向的线程是否存活，如果不存活了，则直接撤销偏向锁。</li>
<li>偏向的线程是否还在同步块中，如果不在了，则撤销偏向锁。</li>
<li>将偏向线程所有相关 Lock Record 的 Displaced Mark Word 设置为null（因为锁重入，会导致Lock Record有多个）。</li>
<li>将第一个 Lock Record 的 Displaced Mark Word  设置为无锁状态，然后将对象头指向这个 Lock Record（这里不需要用CAS指令，因为是在safepoint）。</li>
<li>此时，已经升级成了轻量级锁。</li>
</ol>
<h3 id="偏向锁释放"><a href="#偏向锁释放" class="headerlink" title="偏向锁释放"></a>偏向锁释放</h3><p>入口在 bytecodeInterpreter.cpp：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">CASE(_monitorexit): &#123;</span><br><span class="line">  oop lockee = STACK_OBJECT(-1);</span><br><span class="line">  </span><br><span class="line">  BasicObjectLock* limit = istate-&gt;monitor_base();</span><br><span class="line">  BasicObjectLock* most_recent = (BasicObjectLock*) istate-&gt;stack_base();</span><br><span class="line">  </span><br><span class="line">  // 遍历栈的 Lock Record</span><br><span class="line">  while (most_recent != limit ) &#123;</span><br><span class="line">  </span><br><span class="line">    // ## 1. 找到关联锁对象的 Lock Record</span><br><span class="line">    if ((most_recent)-&gt;obj() == lockee) &#123;</span><br><span class="line">      BasicLock* lock = most_recent-&gt;lock();</span><br><span class="line">      markOop header = lock-&gt;displaced_header();</span><br><span class="line">      // 设置 obj 字段为 null</span><br><span class="line">      most_recent-&gt;set_obj(NULL);</span><br><span class="line">      </span><br><span class="line">      // ## 2. 如果是偏向锁，可以返回了，否则走轻量级锁、重量级锁的释放流程。</span><br><span class="line">      if (!lockee-&gt;mark()-&gt;has_bias_pattern()) &#123;</span><br><span class="line">        bool call_vm = UseHeavyMonitors;</span><br><span class="line">        if (header != NULL || call_vm) &#123;</span><br><span class="line">          if (call_vm || Atomic::cmpxchg_ptr(header, lockee-&gt;mark_addr(), lock) != lock) &#123;</span><br><span class="line">            most_recent-&gt;set_obj(lockee);</span><br><span class="line">            CALL_VM(InterpreterRuntime::monitorexit(THREAD, most_recent), handle_exception);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      UPDATE_PC_AND_TOS_AND_CONTINUE(1, -1);</span><br><span class="line">    &#125;</span><br><span class="line">    most_recent++;</span><br><span class="line">  &#125;</span><br><span class="line">  // Need to throw illegal monitor state exception</span><br><span class="line">  CALL_VM(InterpreterRuntime::throw_illegal_monitor_state_exception(THREAD), handle_exception);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>偏向锁释放就直接把 Lock Record 释放掉就可以了。</p>
<h3 id="批量重偏向和批量撤销"><a href="#批量重偏向和批量撤销" class="headerlink" title="批量重偏向和批量撤销"></a>批量重偏向和批量撤销</h3><p>在前面提到过：</p>
<ul>
<li>每次撤销偏向锁的时候都通过<code>update_heuristics</code>方法记录下来</li>
<li>以类为单位，当某个类的对象撤销偏向次数达到一定阈值的时候JVM就认为该类不适合偏向模式或者需要重新偏向另一个对象</li>
<li>通过 VM Thread 在 【safepoint】时进行【批量撤销】或【批量重偏向】</li>
</ul>
<p>VM Thread调用下面这个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">static BiasedLocking::Condition bulk_revoke_or_rebias_at_safepoint(oop o,</span><br><span class="line">                                                                   bool bulk_rebias,</span><br><span class="line">                                                                   bool attempt_rebias_of_object,</span><br><span class="line">                                                                   JavaThread* requesting_thread) &#123;</span><br><span class="line">  </span><br><span class="line">  // ... 省略</span><br><span class="line">  </span><br><span class="line">  jlong cur_time = os::javaTimeMillis();</span><br><span class="line">  o-&gt;blueprint()-&gt;set_last_biased_lock_bulk_revocation_time(cur_time);</span><br><span class="line">  </span><br><span class="line">  klassOop k_o = o-&gt;klass();</span><br><span class="line">  Klass* klass = Klass::cast(k_o);</span><br><span class="line">  </span><br><span class="line">  // ## 1. 批量重偏向</span><br><span class="line">  if (bulk_rebias) &#123;</span><br><span class="line">  </span><br><span class="line">    // ## 1.1 只有 klass 的 markOop 是偏向模式，才去更新 【epoch】 字段</span><br><span class="line">    //  如果不是偏向模式，说明有其他的 【VM operation】导致这个 markOop 被修改。</span><br><span class="line">    if (klass-&gt;prototype_header()-&gt;has_bias_pattern()) &#123;</span><br><span class="line">    </span><br><span class="line">      // ## 1.2 【epoch】自增</span><br><span class="line">      int prev_epoch = klass-&gt;prototype_header()-&gt;bias_epoch();</span><br><span class="line">      klass-&gt;set_prototype_header(klass-&gt;prototype_header()-&gt;incr_bias_epoch());</span><br><span class="line">      int cur_epoch = klass-&gt;prototype_header()-&gt;bias_epoch();</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      // ## 1.3 遍历所有线程</span><br><span class="line">      for (JavaThread* thr = Threads::first(); thr != NULL; thr = thr-&gt;next()) &#123;</span><br><span class="line">      </span><br><span class="line">        // ## 1.3.1 获取此线程的所有 Lock Record</span><br><span class="line">        GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(thr);</span><br><span class="line">        </span><br><span class="line">        // ## 1.3.2 遍历此线程的所有 Lock Record</span><br><span class="line">        for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) &#123;</span><br><span class="line">          MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span><br><span class="line">          oop owner = mon_info-&gt;owner();</span><br><span class="line">          markOop mark = owner-&gt;mark();</span><br><span class="line">          </span><br><span class="line">          // ## 1.3.3 如果 Lock Record 关联的锁对象是这个 klass 类型的，更新锁对象的【epoch】</span><br><span class="line">          if ((owner-&gt;klass() == k_o) &amp;&amp; mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">            // We might have encountered this object already in the case of recursive locking</span><br><span class="line">            assert(mark-&gt;bias_epoch() == prev_epoch || mark-&gt;bias_epoch() == cur_epoch, &quot;error in bias epoch adjustment&quot;);</span><br><span class="line">            owner-&gt;set_mark(mark-&gt;set_bias_epoch(cur_epoch));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 撤销这个锁对象的偏向锁</span><br><span class="line">    revoke_bias(o, attempt_rebias_of_object &amp;&amp; klass-&gt;prototype_header()-&gt;has_bias_pattern(), true, requesting_thread);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  // ## 2. 批量撤销</span><br><span class="line">  else &#123;</span><br><span class="line">  </span><br><span class="line">    // ## 2.1 关闭这个 klass 的偏向锁，会导致后面：</span><br><span class="line">    //   （1） 分配属于这个 klass 的实例，处于【无锁模式】</span><br><span class="line">    //   （2） 获取这个对象的锁时，获取轻量级锁</span><br><span class="line">    klass-&gt;set_prototype_header(markOopDesc::prototype());</span><br><span class="line">    </span><br><span class="line">    // ## 2.2 遍历所有线程的栈，对于已存在的这个 klass 的已偏向实例，撤销它们的偏向锁</span><br><span class="line">    for (JavaThread* thr = Threads::first(); thr != NULL; thr = thr-&gt;next()) &#123;</span><br><span class="line">      GrowableArray&lt;MonitorInfo*&gt;* cached_monitor_info = get_or_compute_monitor_info(thr);</span><br><span class="line">      for (int i = 0; i &lt; cached_monitor_info-&gt;length(); i++) &#123;</span><br><span class="line">        MonitorInfo* mon_info = cached_monitor_info-&gt;at(i);</span><br><span class="line">        oop owner = mon_info-&gt;owner();</span><br><span class="line">        markOop mark = owner-&gt;mark();</span><br><span class="line">        if ((owner-&gt;klass() == k_o) &amp;&amp; mark-&gt;has_bias_pattern()) &#123;</span><br><span class="line">          revoke_bias(owner, false, true, requesting_thread);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     // 撤销这个锁对象的偏向锁</span><br><span class="line">    revoke_bias(o, false, true, requesting_thread);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="偏向锁的目的"><a href="#偏向锁的目的" class="headerlink" title="偏向锁的目的"></a>偏向锁的目的</h4><p>对于场景为：锁不但没有多线程竞争，而且总是由同一个线程获取，使用偏向锁可以提高性能。</p>
<h4 id="偏向锁的获取"><a href="#偏向锁的获取" class="headerlink" title="偏向锁的获取"></a>偏向锁的获取</h4><p>Java线程执行字节码<code>monitorenter</code>，开始同步块的访问，流程如下：</p>
<ul>
<li>(1) 先检查对象头 Mark Word 中的【bias_pattern】是否为 “101”<ul>
<li>如果是（即处于【偏向锁状态】），进入【偏向锁的获取】的流程</li>
<li>如果不是，进入【轻量级锁获取的流程】</li>
</ul>
</li>
<li>(2) 检查对象头 Mark Word 中记录的 Thread ID 是否是当前线程ID<ul>
<li>如果是：说明当前线程已经获得此对象的偏向锁（锁重入）<ul>
<li>只需要在栈添加一条 Lock Record（类型为<code>MonitorInfo</code>），不需要 CAS 操作，因为操作的是自己的栈</li>
<li>不需要操作锁对象</li>
</ul>
</li>
<li>如果不是，进行一些检查（主要是为了支持“批量重偏向和批量撤销”）</li>
</ul>
</li>
<li>(3) 检查对象所属类是否不再支持偏向<ul>
<li>是由于发生了【批量撤销】导致的</li>
<li>进入到【获取轻量级锁】的流程</li>
</ul>
</li>
<li>(4) 检查当前对象的 Epoch 是否为不合法（不等于 klass 的 Epoch）<ul>
<li>是由于发生了【批量重偏向】导致的</li>
<li>说明对象之前的偏向是无效了，需要【重偏向】</li>
<li>尝试使用 CAS 替换对象头 Mark Word 中的 Thread ID 为当前线程ID<ul>
<li>如果成功， 表示获取到偏向锁</li>
<li>如果失败，需要进入【获取轻量级锁】的流程</li>
</ul>
</li>
</ul>
</li>
<li>(5) 通过CAS 操作，将当前线程ID替换进对象的 Mark Word，此时有2种情况：<ul>
<li>当前对象处于【匿名偏向锁状态（可偏向未锁定）】，这种情况会替换成功（即获取到锁），而且同样会在栈添加一条 Lock Record。</li>
<li>偏向锁被其他线程拥有，这种情况会替换失败，开始进行【偏向锁撤销】。这个是偏向锁的特点：等到出现竞争才释放锁。</li>
</ul>
</li>
</ul>
<h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p><font color="orange">撤销是指在获取偏向锁的过程因为不满足条件导致要将锁对象改为非偏向锁状态</font>。</p>
<p>流程如下：</p>
<ul>
<li>(1) 如果 klass 关闭了偏向锁，即发生了 【批量撤销】，使用 CAS 设置对象的 Mark Word，然后返回。</li>
<li>(2) 如果锁对象的epoch过期了，意味着这个对象的状态是【未偏向】的：<ul>
<li>直接通过 CAS 操作设置对象的 Mark Word 将锁撤销或重偏向</li>
<li>不需要记录锁撤销</li>
</ul>
</li>
<li>(3) 更新这个 klass 的偏向锁撤销的次数，和相关阈值比较，有2种情况：<ul>
<li>撤销单个线程获得的偏向锁<ul>
<li>如果是当前线程自己的偏向锁，直接执行偏向锁撤销逻辑</li>
<li>如果是其他线程的偏向锁，需要由VM线程执行</li>
</ul>
</li>
<li>批量撤销、批量重偏向：由VM线程执行</li>
</ul>
</li>
<li>(4) 偏向锁撤销逻辑：<ul>
<li>查看偏向的线程是否存活，如果不存活了，则直接撤销偏向锁。</li>
<li>偏向的线程是否还在同步块中，如果不在了，则撤销偏向锁。</li>
<li>将偏向线程所有相关 Lock Record 的 Displaced Mark Word 设置为null（因为锁重入，会导致Lock Record有多个）。</li>
<li>将第一个 Lock Record 的 Displaced Mark Word  设置为无锁状态，然后将对象头指向这个 Lock Record（这里不需要用CAS指令，因为是在safepoint）。</li>
</ul>
</li>
</ul>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/23/JVM_Synchronized_Introduce/" rel="next" title="Synchronized底层实现—-概述">
                <i class="fa fa-chevron-left"></i> Synchronized底层实现—-概述
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/25/JVM_Synchronized_LightWeight/" rel="prev" title="Synchronized底层实现—-轻量级锁">
                Synchronized底层实现—-轻量级锁 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">JH_Chen</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">66</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁获取"><span class="nav-number">2.</span> <span class="nav-text">偏向锁获取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁撤销"><span class="nav-number">3.</span> <span class="nav-text">偏向锁撤销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#偏向锁释放"><span class="nav-number">4.</span> <span class="nav-text">偏向锁释放</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#批量重偏向和批量撤销"><span class="nav-number">5.</span> <span class="nav-text">批量重偏向和批量撤销</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#总结"><span class="nav-number">6.</span> <span class="nav-text">总结</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁的目的"><span class="nav-number">6.1.</span> <span class="nav-text">偏向锁的目的</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁的获取"><span class="nav-number">6.2.</span> <span class="nav-text">偏向锁的获取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#偏向锁的撤销"><span class="nav-number">6.3.</span> <span class="nav-text">偏向锁的撤销</span></a></li></ol></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JH_Chen</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.1</div>






        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>



  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
